<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022.10.2 剑指56题</title>
      <link href="/2022/10/02/leetcode/jianzhi56/"/>
      <url>/2022/10/02/leetcode/jianzhi56/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例1</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><h2 id="解法讲解及心得"><a href="#解法讲解及心得" class="headerlink" title="解法讲解及心得"></a>解法讲解及心得</h2><p>这题可以说是leetcode136题的进阶版<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p>同时也不得不让人感慨位运算的神奇，位运算可以用来做快速幂计算，同时还可以用在树状数组还有本题的查找不同的题目中。</p><p>在讲这道题之前想先记下有意思的几种位运算的方法</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或 ^"></a>异或 ^</h3><p>异或运算有以下三个性质。</p><ol><li>任何数和 00 做异或运算，结果仍然是原来的数，即a⊕0&#x3D;a</li><li>任何数和其自身做异或运算，结果是 0，即 a⊕a&#x3D;0</li><li>异或运算满足交换律和结合律，即 a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b</li></ol><p>可以看到这个异或运算在寻找只出现一次的数字，能起到关键作用，我们只需要将数组从头异或到最后，便可以得到我们的答案。</p><h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>lowbit这个概念我是从树状数组知道的，树状数组是一个求前缀和和单点更新的数组，查找和更新的概率都是O（logn），但这类数组实际上除了特定题，我觉得一般很少看到，暂时做了解即可，它出现在<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/?favorite=xb9nqhhg">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a>可以从这道题了解树状数组的用法。</p><p>言归正传，我们假设一个数字x，lowbit运算为x&amp;（-x）这个运算可以得到x二进制表示中最后的“1”，这确实十分神奇，为什么不需要知道，知道他能实现这个效果就行，比如010100经过lowbit运输为000100；</p><p>在了解完这两个解题技巧之后，我们开始正式讲这道题的解法：</p><ol><li><strong>我们首先对整个数组进行异或运算，如下公式：</strong></li></ol><p><em>a</em>⊕<em>a</em>⊕<em>b</em>⊕<em>b</em>⊕…⊕<em>x</em>⊕<em>y</em></p><p>&#x3D;0⊕0⊕…⊕<em>x</em>⊕<em>y</em></p><p>&#x3D;<em>x</em>⊕<em>y</em></p><p>&#x3D;ret</p><p>很明显我们会发现这样没办法得到两个数字，而是得到他们的异或。但是巧妙的地方就在于我们知道x和y是必不相等的，所以他们两的异或得到的二进制的值必然不为0，于是有了下面的步骤</p><ol start="2"><li><strong>对ret进行lowbit运算</strong></li></ol><p>我们已经知道了ret不为0，然后我们使用lowbit能得到ret最靠后的“1”，那么这代表什么呢？</p><p>这代表x和y的二进制表达在这一位上他们是不一样的，要么x在这一位上为0，y为1；要么相反x在这一位上是1，y为0。</p><p>div&#x3D;ret&amp;（-ret）</p><p>有了这样的运算之后，我们看第三个步骤</p><ol start="3"><li><strong>对原数组进行分组计算</strong></li></ol><p>这一步简直是神来之笔，只能说没做过这类型的题简直不可能想出这个方法，有天赋的人除外了。</p><p>我们这一步要做到两个效果</p><ul><li>相同的数字必定在一组</li><li>返回的两个不同数字必定在不同的组</li></ul><p>我们通过lowbit运算之后得到的div，也就是最靠后的“1”的数字，用来和数组中的所有数进行与（&amp;）运算，将这一位上与div相同的分到一组，不相同的分到另一组。很明显，我们已经巧妙的将两个不同数字分开的同时，将相同的数字放到了一组。最后我们能得到两个数字，这便是题目要的答案</p><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 我们首先对整个数组进行异或运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ret ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对ret进行lowbit运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> ret &amp; (-ret);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对原数组进行分组计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div&amp;num)==<span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.9.16 剑指43题</title>
      <link href="/2022/09/16/leetcode/jianzhi43/"/>
      <url>/2022/09/16/leetcode/jianzhi43/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5</p><p><strong>示例1：</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt; 2^31</code></li></ul><h2 id="解法讲解："><a href="#解法讲解：" class="headerlink" title="解法讲解："></a>解法讲解：</h2><p>该题十分独特所以放上来记录一下</p><p>如果玩过行李箱那个密码锁能很好理解，没玩过也无所谓。</p><p>我们常见的最暴力的解法就是从1遍历到n，这是效率十分低下的解法。</p><p>但如果仔细观察规律，通过计算每一个位置在1~n里面出现1的次数，最后再将所有位置数到1的数量追加起来就可以得到最终结果</p><p>举个例子讲解一下：</p><p>拿24x5做例子</p><p>其中x为我们锁定的位置<strong>cur</strong></p><p>24为高位<strong>high</strong></p><p>5为低位<strong>low</strong></p><p>我们可以用digit表示我们目前锁定的位置<strong>digit</strong>（当前digit&#x3D;10）</p><p>我们开始计算十位的数量</p><ol><li>当十位为0时，那么也就是说1不可能出现在2410之后，所以实际上只有<strong>0010~2319</strong>这段数字区间十位会出现1，我们暂时把十位遮掉，可以发现变成了计算<strong>000~239</strong>的总数量，也就是240；（归纳：当锁定位置为0时，只看高位数量）</li><li>当十位为1，那么出现1的次数很明显会比第一个情况有所增加，这个时候<strong>0010~2415</strong>这段区间十位会出现1，同样遮掉十位数，这下变成了<strong>000~245</strong>的总数量，总共为246；（归纳：当锁定位置为1时，要同时看高低位数量）</li><li>当十位&gt;1时，和上面一样的推理，这个时候区间就会变成<strong>0010~2419</strong>这个区间，这是因为当十位数大于1时，假设为2，小于2420这个数字且十位数为1的最大数字为2419，遮掉十位数，求<strong>000~249</strong>，总共为250；（归纳：当锁定位置大于1时，只看高位数量，（高位+1）*10）</li></ol><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (high!=<span class="number">0</span>||cur!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur==<span class="number">0</span>) &#123;</span><br><span class="line">                res += high*digit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur==<span class="number">1</span>) &#123;</span><br><span class="line">                res += high*digit+low+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (high+<span class="number">1</span>)*digit;</span><br><span class="line">            &#125;</span><br><span class="line">            digit*=<span class="number">10</span>;</span><br><span class="line">            low = cur*digit+low;</span><br><span class="line">            cur = high%<span class="number">10</span>;</span><br><span class="line">            high = high/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud中nacos config的一些坑</title>
      <link href="/2022/06/29/spring/nacosconfig/"/>
      <url>/2022/06/29/spring/nacosconfig/</url>
      
        <content type="html"><![CDATA[<p>我在弄nacos config按照网上的流程打了一遍，发现并没有在日志弹出配置文件的名字，可能是版本的问题<br>解决方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后便能在控制台的日志看到<br><img src="https://s3.bmp.ovh/imgs/2022/06/29/c0f28361f6dbe63e.png" alt="img"><br>无视第三行，直接看第二行nacos相关的，复制gulimall-coupon.properties即可</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.15 77题</title>
      <link href="/2022/05/15/leetcode/77/"/>
      <url>/2022/05/15/leetcode/77/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfsa(res,list,n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsa</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list,<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> begin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size()==k) &#123;</span><br><span class="line">            List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">            res.add(list1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            dfsa(res,list,n,k,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感谢"><a href="#做题感谢" class="headerlink" title="做题感谢"></a>做题感谢</h1><p>回溯法这类题做多了十分简单</p><p>在for那里，设置begin有点学问，可以多试试</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.13 108题</title>
      <link href="/2022/05/13/leetcode/108/"/>
      <url>/2022/05/13/leetcode/108/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="img"></p><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> travel(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">travel</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = travel(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = travel(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><p>首先是递归函数的参数，因为我们需要用到多的参数，所以我们要重新定义一个递归函数出来。</p><p>其他的与普通递归函数无异。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.9 669题</title>
      <link href="/2022/05/09/leetcode/669/"/>
      <url>/2022/05/09/leetcode/669/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><p>树中节点数在范围 [1, 104] 内</p></li><li><p>0 &lt;&#x3D; Node.val &lt;&#x3D; 104</p></li><li><p>树中每个节点的值都是 唯一 的</p></li><li><p>题目数据保证输入是一棵有效的二叉搜索树</p></li><li><p>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 104</p></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val&lt;low) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val&gt;high) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><p>这可能是我最近做的最糟糕的一题，其实本题并不难，看了解法逻辑十分清晰。</p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/image-20220509105537316.png" alt="imgae12"></p><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><pre><code>    TreeNode</code></pre><p><strong>（2）确定终止条件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>（3）确定单层递归的逻辑</strong></p><p>ps：<strong>注意这里我本来以为和450题一样，修剪就行，但实际上修剪一次和修剪多次是不一样了，所以解法大不相同。</strong></p><p>​如果root（当前节点）的元素小于左边界low的数值，那么应该递归右子树，并返回右子树符合条件的头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val&lt;low) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​如果root（当前节点）的元素大于左边界high的数值，那么应该递归左子树，并返回左子树符合条件的头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val&gt;high) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​接下来将下一层递归处理左子树的结果赋值给root.left、处理右子树的结果赋值给root.right，最后返回root节点，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root.left = trimBST(root.left,low,high);</span><br><span class="line">root.right = trimBST(root.right,low,high);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.7 450题</title>
      <link href="/2022/05/07/leetcode/450/"/>
      <url>/2022/05/07/leetcode/450/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt="img"></p><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 [0, 104].</li><li>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</li><li>节点值唯一</li><li>root 是合法的二叉搜索树</li><li>-105 &lt;&#x3D; key &lt;&#x3D; 105</li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">         <span class="comment">//情况一找不到该节点，返回root</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">//情况二，该节点左右孩子均为空，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//情况三，左孩子为空，右孩子不为空</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span> )</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="comment">//情况四，右孩子为空，左孩子不为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right==<span class="literal">null</span> )</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">//情况五，左右孩子都不为空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right; <span class="comment">// 首先找到删除节点的右子树</span></span><br><span class="line">                <span class="comment">//找到右子树中最小的数字</span></span><br><span class="line">               <span class="keyword">while</span> (cur.left!=<span class="literal">null</span>) &#123; </span><br><span class="line">                   cur =cur.left;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将原本的左子树拼接上去</span></span><br><span class="line">                cur.left=root.left;</span><br><span class="line">               <span class="comment">// 取代root</span></span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right,key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><pre><code>    TreeNode</code></pre><p><strong>（2）确定终止条件</strong></p><pre><code>    即遍历到null的时候</code></pre><p><strong>（3）确定单层递归的逻辑</strong></p><p>主要分析五种情况</p><ul><li>第一种情况：没有找到删除的节点</li><li>找到了删除的节点<ul><li>第二种情况：该节点左右孩子都为空。</li><li>第三种情况：被删除的节点左孩子为空，右孩子不为空。</li><li>第四种情况：被删除的节点右孩子为空，左孩子不为空。</li><li>第五种情况：被删除的节点左右孩子都不为空。</li></ul></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//情况一找不到该节点，返回root</span><br><span class="line">      if (root == null) return root;</span><br><span class="line">      if (root.val == key) &#123;</span><br><span class="line">          //情况二，该节点左右孩子均为空，返回null</span><br><span class="line">          if (root.left==null &amp;&amp; root.right==null)return null;</span><br><span class="line">          //情况三，左孩子为空，右孩子不为空</span><br><span class="line">          if (root.left==null )</span><br><span class="line">              return root.right;</span><br><span class="line">          //情况四，右孩子为空，左孩子不为空</span><br><span class="line">          else if (root.right==null )</span><br><span class="line">              return root.left;</span><br><span class="line">          //情况五，左右孩子都不为空</span><br><span class="line">          else &#123;</span><br><span class="line">             TreeNode cur = root.right; // 首先找到删除节点的右子树</span><br><span class="line">              //找到右子树中最小的数字</span><br><span class="line">             while (cur.left!=null) &#123; </span><br><span class="line">                 cur =cur.left;</span><br><span class="line">             &#125;</span><br><span class="line">             //将原本的左子树拼接上去</span><br><span class="line">              cur.left=root.left;</span><br><span class="line">             // 取代root</span><br><span class="line">              root = root.right;</span><br><span class="line">              return root;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.6 701题</title>
      <link href="/2022/05/06/leetcode/701/"/>
      <url>/2022/05/06/leetcode/701/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果。</p><p><strong>示例1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt="img"></p><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中的节点数将在 [0, 104]的范围内。</p></li><li><p>-108 &lt;&#x3D; Node.val &lt;&#x3D; 108</p></li><li><p>所有值 Node.val 是 独一无二 的。</p></li><li><p>-108 &lt;&#x3D; val &lt;&#x3D; 108</p></li><li><p>保证 val 在原始BST中不存在。</p></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感谢"><a href="#做题感谢" class="headerlink" title="做题感谢"></a>做题感谢</h1><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><p>​TreeNode</p><p><strong>（2）确定终止条件</strong></p><p>​即遍历到null的时候</p><p><strong>（3）确定单层递归的逻辑</strong></p></li></ol><p></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">&#125;</span><br><span class="line">if (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置说明</title>
      <link href="/2022/05/05/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/05/05/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、每次修改config.yml文件之后要先使用hexo server修改配置并查看预览。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>2、预览无问题之后，上传到github</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;作出的修改&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>3、同步到github托管</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>4、当出现如下图的error时</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">fatal: <span class="title">unable</span> <span class="title">to</span> <span class="title">access</span> &#x27;<span class="title">https</span>://<span class="title">github.com</span>/<span class="title">yu1147</span>/<span class="title">blog.git</span>/&#x27;: <span class="title">OpenSSL</span> <span class="title">SSL_read</span>: <span class="title">Connection</span> <span class="title">was</span> <span class="title">reset</span>, <span class="title">errno</span> 10054</span></span><br></pre></td></tr></table></figure><p>输入下面指令即可</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/05/05/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/05/05/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shu.pension.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About me</title>
      <link href="/2022/05/05/%E7%BD%AE%E9%A1%B6%E9%A1%B5/aboutme/"/>
      <url>/2022/05/05/%E7%BD%AE%E9%A1%B6%E9%A1%B5/aboutme/</url>
      
        <content type="html"><![CDATA[<p>cover: <a href="https://s3.bmp.ovh/imgs/2022/05/14/5af5ca311486c8e8.jpg">https://s3.bmp.ovh/imgs/2022/05/14/5af5ca311486c8e8.jpg</a></p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>我是陈诗杰。目前上海大学就读研究生在读。主要钻研后端开发、神经网络架构搜索。</p><h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1><div align=left><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/java.png" alt="java" style="zoom: 15%;float:left" /></div><div align=left><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/python.png" alt="python" style="zoom:15%;float:left" /></div><div align=left><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/linux.png" alt="linux" style="zoom:15%;float:left" /></div><p> &nbsp</p><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>qq：1147669839</p><p>微博：@学徒型谕桑</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=595608323&bvid=BV1yB4y1m7PP&cid=573439540&page=1&as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0; " sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/04/hello-world/"/>
      <url>/2022/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
