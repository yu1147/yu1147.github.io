<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统中的io模型</title>
      <link href="/2023/03/30/operatingSystem/IO/"/>
      <url>/2023/03/30/operatingSystem/IO/</url>
      
        <content type="html"><![CDATA[<p>这道题是拼多多二面问的，并没有得到面试官的认可，因此做一个笔记整理一下，下次遇到可以好好地回答。</p><p>首先感谢凋零提供的笔记。</p><p>下面正文</p><hr><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>本文主要将同步和异步、阻塞和非阻塞这些关系屡清，同时结合java的情况。分析角度会从现象到操作系统剖析。</p><h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>I&#x2F;O(Input&#x2F;Output)即输入&#x2F;输出</p><blockquote><p>从两个角度看待IO</p></blockquote><p>从<strong>计算机结构的视角</strong>来看的话，I&#x2F;O描述了计算机系统与外部设备之间通信的过程。</p><p>从<strong>应用程序的角度</strong>来看：我们的应用程序对操作系统的内核发起IO调用（系统调用），操作系统负责的内核执行具体的IO操作。也就是说，我们的应用程序实际上只是发起了IO操作的调用，具体IO的执行是由操作系统的内核来完成的。</p><p>通常开发过程中，接触最多的是<strong>磁盘IO（读写文件）</strong>和<strong>网络IO（网络请求和响应）</strong>。</p><h2 id="IO的两个阶段"><a href="#IO的两个阶段" class="headerlink" title="IO的两个阶段"></a>IO的两个阶段</h2><ol><li>内核等待I&#x2F;O设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><blockquote><p>以读文件为例说一下这两个阶段到底是什么意思</p></blockquote><p>当应用程序调用read()系统调用来读取文件时，操作系统会在内核空间中执行IO操作。在等待IO操作完成并将数据准备好的阶段，操作系统会从磁盘中读取文件的内容，并将数据存储在内核空间的缓冲区中。</p><p>当IO操作完成并数据准备好后，操作系统就会将数据从内核空间拷贝到应用程序的用户空间中，供应用程序使用。</p><blockquote><p>什么是用户空间？什么是内核空间呢？</p></blockquote><p>一个进程的地址空间划分为用户空间和内和空间。</p><p>像我们平常运行的应用程序都是运行在内核空间。</p><p>而对于文件管理、进程通信、内存管理等等与系统态级别的资源都位于内核空间。</p><p>也就是说，我们要想调用这些系统态级别的资源就需要发起系统调用，请求操作系统帮忙完成I&#x2F;O操作。</p><h2 id="常见的IO模型"><a href="#常见的IO模型" class="headerlink" title="常见的IO模型"></a>常见的IO模型</h2><p>IO模型一般有5种：</p><ul><li>[同步阻塞IO]</li><li>[同步非阻塞IO]</li><li>[IO多路复用]</li><li>信号驱动IO</li><li>[异步IO]<br>其中java常见的有三种IO模型：BIO,NIO,AIO</li></ul><p>为了更好地理解上面这几个模型，我们分别讲完之后再增设对比组。这也是取决于面试的时候，面试官问题的角度从而做出一些对比讲解。</p><p>↓↓快速导航↓↓</p><p><a href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO">同步阻塞IO与同步非阻塞IO</a></p><p><a href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E5%BC%82%E6%AD%A5IO">同步IO与异步IO</a></p><h2 id="同步阻塞IO-BIO-Blocking-IO"><a href="#同步阻塞IO-BIO-Blocking-IO" class="headerlink" title="同步阻塞IO(BIO,Blocking IO)"></a>同步阻塞IO(BIO,Blocking IO)</h2><p>我们从IO的两个阶段分析什么是同步阻塞IO</p><p>在同步阻塞IO中，应用程序会不断轮询访问内核是否已经完成IO操作并将数据准备好放到内核缓冲区中，这个时候应用程序是被<strong>阻塞</strong>的。</p><p>接着在数据拷贝阶段中，数据从内核空间拷贝到用户空间，这个时候应用程序也是被<strong>阻塞</strong>的。</p><p>因此，可以说在同步IO模型中，等待数据和数据拷贝两个过程<strong>都会阻塞</strong>应用程序，不会执行其他任务。</p><h2 id="同步非阻塞IO-Non-blocking-IO"><a href="#同步非阻塞IO-Non-blocking-IO" class="headerlink" title="同步非阻塞IO(Non-blocking IO)"></a>同步非阻塞IO(Non-blocking IO)</h2><p>同步非阻塞IO是IO多路复用的基础。</p><p>同样分成两个阶段讲解</p><p>在第一个阶段中，应用程序反复调用read()，等待内核完成IO操作并将数据准备好放在内核缓冲区中，这个时候应用程序<strong>不被阻塞</strong>。</p><p>第二阶段等待数据从内核空间复制到用户空间这个过程中，应用程序是<strong>阻塞</strong>的，直到数据拷贝完成。</p><h2 id="I-x2F-O多路复用（New-IO）"><a href="#I-x2F-O多路复用（New-IO）" class="headerlink" title="I&#x2F;O多路复用（New IO）"></a>I&#x2F;O多路复用（New IO）</h2><p>这个模型在redis中还有netty中是最常用的模型，对于高负载、高并发的应用，应使用NIO。</p><p>IO多路复用模型有三大组件：</p><ol><li><p>Channel</p><p>数据的传输通道。</p></li><li><p>Buffer</p><p>用来缓冲读写数据。</p></li><li><p>Selector</p><p>也可以被称为多路复用器，通过这个线程与内核</p></li></ol><p>IO多路复用可以用来解决同步IO第一阶段不断轮询的问题。</p><p>在IO多路复用模型中，多出一个选择器（selector）为我们监听可能有IO任务的通道。因此应用程序不需要不断去轮询访问内核数据是否准备好了。</p><p>在第一阶段中，应用程序调用线程发出select()调用之后，内核便会去准备数据。等数据准备就绪后，发送ready()命令给应用程序告诉应用程序数据准备好了，这个阶段应用程序是<strong>不会被阻塞</strong>的，但是调用select()的线程在没有收到ready()命令的情况下是<strong>阻塞</strong>的。</p><p>第二阶段拷贝数据的过程中，应用程序依旧是阻塞的。</p><blockquote><p>优点是什么？</p></blockquote><p>用select&#x2F;epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I&#x2F;O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。 </p><blockquote><p>缺点是什么？</p></blockquote><p>本质上，select&#x2F;epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。 </p><h2 id="异步IO-AIO、Asynchronous-I-x2F-O"><a href="#异步IO-AIO、Asynchronous-I-x2F-O" class="headerlink" title="异步IO(AIO、Asynchronous I&#x2F;O)"></a>异步IO(AIO、Asynchronous I&#x2F;O)</h2><p>异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前这个的应用并不广泛。</p><p>只有IO请求操作的发出是用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。</p><h2 id="同步阻塞IO与同步非阻塞IO"><a href="#同步阻塞IO与同步非阻塞IO" class="headerlink" title="同步阻塞IO与同步非阻塞IO"></a>同步阻塞IO与同步非阻塞IO</h2><p>这两者的主要区别在于第一阶段等待数据准备好的时候，同步阻塞IO是<strong>阻塞</strong>的，而同步非阻塞IO是<strong>非阻塞的</strong>。</p><p>这两个IO模型，都存在着一个问题，那就是第一阶段不断轮询访问数据是否准备好了这个过程，是十分消耗CPU资源的</p><h2 id="同步阻塞IO与异步IO"><a href="#同步阻塞IO与异步IO" class="headerlink" title="同步阻塞IO与异步IO"></a>同步阻塞IO与异步IO</h2><p>同步IO与异步IO主要的区别在于IO操作的方式以及在IO操作期间进程是否会被阻塞。</p><p>同步IO和异步IO模型是针对用户空间和内核空间的交互来说的</p><blockquote><p>说说同步阻塞IO</p></blockquote><p>我们从IO的两个阶段分析什么是同步IO</p><p>在同步阻塞IO中，应用程序会不断轮询访问内核是否已经完成IO操作并将数据准备好放到内核缓冲区中，这个时候应用程序是被阻塞的。</p><p>接着在数据拷贝阶段中，数据从内核空间拷贝到用户空间，这个时候应用程序也是被阻塞的。</p><p>因此，可以说在同步IO模型中，等待数据和数据拷贝两个过程都会阻塞应用程序，不会执行其他任务。</p><blockquote><p>说说异步IO</p></blockquote><p>只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。</p><blockquote><p>两者区别</p></blockquote><p>同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。</p><h2 id="同步-x2F-异步和阻塞-x2F-非阻塞的关系"><a href="#同步-x2F-异步和阻塞-x2F-非阻塞的关系" class="headerlink" title="同步&#x2F;异步和阻塞&#x2F;非阻塞的关系"></a><strong>同步</strong>&#x2F;<strong>异步和阻塞</strong>&#x2F;<strong>非阻塞的关系</strong></h2><p>阻塞&#x2F;非阻塞概念是定义在IO的第一个阶段的，同步&#x2F;异步是定义在IO的第二个阶段的</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized锁升级</title>
      <link href="/2023/03/06/juc/%E9%94%81%E5%8D%87%E7%BA%A7/"/>
      <url>/2023/03/06/juc/%E9%94%81%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h1><blockquote><p>synchronized是重量级锁吗</p></blockquote><p>回答是不是的，带java1.5之前，可能是，在那之后就不是了</p><p>java1.5之前主要是通过”monitorenter”和”monitorexit”指令抢锁，过程中涉及到用户态和核心态，由操作系统来负责线程间的调服和线程状态变更，需要频繁在这两个状态上下文切换，开销十分巨大。因此在1.6后，为了提高锁的获取和释放效率，引入了锁升级，也就是引入了两种锁：偏向锁和轻量级锁</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>在synchronized进行升级锁的过程中，第一步会升级为偏向锁，它的本质就是让锁来记住请求的线程。<br>偏向锁的实施就是将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark<br>JVM用biasable标记这个状态，在这个状态下会直接用CAS修改对象头中的线程id，如果成功了，就直接升级为偏向锁，否则进入下一个状态。</p><p>偏向锁状态为<strong>biased</strong>。</p><p>在偏向锁状态下，如果下次这个线程想进入同步区，只需要比较一下线程ID是否相等，不需要再进行CAS或者加锁。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>如果处于偏向锁状态的时候，还有新的线程参与锁的抢夺，那么就会发生锁的升级，进入轻量锁的状态</p><p>状态名为<strong>thin lock</strong>，在这个状态下，线程需要不断使用CAS获取锁。</p><p>但是如果有多写情况下，很可能会导致CAS一直自旋访问，当访问次数到达一定的上限之后，就需要升级为重量级锁了</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>状态名为<strong>fat lock</strong></p><p>当升级为重量级锁的情况下，锁对象的<code>mark word</code>中的指针不再指向线程栈中的<code>lock record</code>，而是指向堆中与锁对象关联的<code>monitor</code>对象。</p><p>当多个线程同时访问同步代码时，这些线程会先尝试获取当前锁对象对应的<code>monitor</code>的所有权：</p><ul><li>获取成功，判断当前线程是不是重入，如果是重入那么<code>recursions+1</code></li><li>获取失败，当前线程会被阻塞，等待其他线程解锁后被唤醒，再次竞争锁对象</li></ul><p>在重量级锁的情况下，加解锁的过程涉及到操作系统的<code>Mutex Lock</code>进行互斥操作，线程间的调度和线程的状态变更过程需要在用户态和核心态之间进行切换，会导致消耗大量的cpu资源，导致性能降低。</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>next-key lock中一些退化情况</title>
      <link href="/2023/02/25/mysql/next-keylock/"/>
      <url>/2023/02/25/mysql/next-keylock/</url>
      
        <content type="html"><![CDATA[<h1 id="next-key-lock研究"><a href="#next-key-lock研究" class="headerlink" title="next-key lock研究"></a>next-key lock研究</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>我们知道next-key lock &#x3D; record lock（记录锁）+gap lock（间隙锁）<br>next-key lock起到的最重要的作用便是避免幻读出现。</p><p>但在一定情况下next-key lock可能会退化为记录锁、或者间隙锁，我们引用一下大佬的笔记与总结</p><p><a href="https://www.xiaolincoding.com/mysql/lock/how_to_lock.html#%E6%80%BB%E7%BB%93">MySQL 是怎么加锁的？ | 小林coding (xiaolincoding.com)</a></p><p>###唯一索引等值查询：</p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li><li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li></ul><h3 id="非唯一索引等值查询："><a href="#非唯一索引等值查询：" class="headerlink" title="非唯一索引等值查询："></a>非唯一索引等值查询：</h3><ul><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后<strong>在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li><li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li></ul><p>###唯一索引的范围查询的加锁规则：</p><ul><li><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</p></li><li><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p><ul><li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li><li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li></ul></li></ul><p>###非唯一索引范围查询</p><p>非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。</p><hr><p>还有一件很重要的事情，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，<strong>如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题。</p><h2 id="引发的思考"><a href="#引发的思考" class="headerlink" title="引发的思考"></a>引发的思考</h2><p>我们知道在一定的情况下，next-key lock可能会退化为记录锁或者间隙锁，学习的过程中，发现间隙锁的情况比较复杂</p><h3 id="间隙锁到底是加在哪里的，他的作用范围是什么"><a href="#间隙锁到底是加在哪里的，他的作用范围是什么" class="headerlink" title="间隙锁到底是加在哪里的，他的作用范围是什么"></a>间隙锁到底是加在哪里的，他的作用范围是什么</h3><p>这么问比较晦涩，我注意到非唯一等值查询时，但他查到第一条不符合条件的二级索引时，会退化为间隙锁。</p><p>我们先给出问题的答案：</p><p>间隙锁一般锁定在右边界上，并且是左开右开的。也就是说，如果一个间隙锁的范围是 (a, b），它会锁住 a &lt; x &lt; b 区间内的所有值，这不影响修改已存在记录b的值。（特别注意next-key锁时左开右闭的，这是因为加上了记录锁，把右边界锁定上了）</p><p>举个例子，表结构如下</p><table><thead><tr><th>id</th><th>age</th><th>name</th><th>sex</th></tr></thead><tbody><tr><td>1</td><td>12</td><td>abc</td><td>1</td></tr><tr><td>2</td><td>13</td><td>dsa</td><td>1</td></tr><tr><td>3</td><td>13</td><td>wdw</td><td>0</td></tr><tr><td>4</td><td>14</td><td>wsd</td><td>0</td></tr></tbody></table><p>假设age为二级索引，且非唯一。执行下面语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">13</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>那么他会给id为2和3的行加 <strong>next-key lock</strong>，当他搜索到第一个不符合查询要求的行，即id&#x3D;4一行，会加上间隙锁。我的疑惑在于为什么不锁id&#x3D;1，这是因为间隙锁一般是锁定在右边界上的，也就是说当id为2的行有<strong>next-key lock</strong>这个锁时（我们知道next-key lock &#x3D; record lock（记录锁）+gap lock（间隙锁），这就意味着id为2上也是有间隙锁的，所以（1,2）上有间隙锁。因此不需要考虑1的情况了。</p><p>类推一下，当查找的值不存在时</p><p>假设一张表有id为1,5,6的值，我使用select id&#x3D;3 from xxx for update，那间隙锁的范围就是(1,5）</p><p>最后还有注意的一点如果你想在REPEATABLE READ 的隔离级别开启next-key lock功能，那你一定要在事务开启使用select的时候加上for update，这也说明了MVCC并不能完全避免幻读。</p><p>分析这类退化题其实十分简单，无非就是划分区间，如果你不想让边界被包括进去，那就一定要把边界变为间隙锁。</p><p>而如果是唯一索引，那么边界往往不需要范围，比如说&gt;&#x3D;15,如果存在15，那直接把15变为记录锁即可。具体情况具体分析，</p><p>非唯一索引还要考虑是否要对主键加记录锁</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker定制mysql容器</title>
      <link href="/2023/02/25/spring/%E5%AE%9A%E5%88%B6%E5%8C%96mysql%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/02/25/spring/%E5%AE%9A%E5%88%B6%E5%8C%96mysql%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="定制化mysql容器"><a href="#定制化mysql容器" class="headerlink" title="定制化mysql容器"></a>定制化mysql容器</h1><h2 id="写dockerfile"><a href="#写dockerfile" class="headerlink" title="写dockerfile"></a>写dockerfile</h2><p>准备好初始化用的sql文件和运行sql文件的脚本</p><p>定制化容器时将</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> YZ</span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH /usr/local/work</span><br><span class="line"><span class="keyword">ENV</span> AUTO_RUN_DIR /docker-<span class="keyword">entrypoint</span><span class="language-bash">-initdb.d</span></span><br><span class="line"><span class="keyword">ENV</span> INSTALL_DATA_SHELL install_data.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="variable">$WORK_PATH</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./<span class="variable">$FILE_0</span> <span class="variable">$WORK_PATH</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./<span class="variable">$INSTALL_DAAT_SHELL</span> <span class="variable">$AUTO_RUN_DIR</span>/</span></span><br><span class="line"><span class="comment">## 容器时区问题</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 复制数据库文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./db/ra.sql <span class="variable">$WORK_PATH</span>/</span></span><br></pre></td></tr></table></figure><h2 id="写install-data-sh"><a href="#写install-data-sh" class="headerlink" title="写install_data.sh"></a>写install_data.sh</h2><p>在dockerfile下新建一个install_data.sh</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">mysql -uroot -p<span class="variable">$MYSQL_ROOT_PASSWORD</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">source $WORK_PATH/ra.sql;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡</title>
      <link href="/2023/01/15/spring/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2023/01/15/spring/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用nginx做负载均衡"><a href="#如何用nginx做负载均衡" class="headerlink" title="如何用nginx做负载均衡"></a>如何用nginx做负载均衡</h1><h2 id="举一个实际的应用场景"><a href="#举一个实际的应用场景" class="headerlink" title="举一个实际的应用场景"></a>举一个实际的应用场景</h2><p>假设我两台机器的后端（包括端口号）分别是192.168.8.171:8082和192.168.8.176:8083，nginx部署在192.168.8.171</p><p>那么nginx的配置应该是</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">upstream backend_servers &#123;</span><br><span class="line">    server 192.168.8.171:8082;</span><br><span class="line">    server 192.168.8.176:8083;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 192.168.8.171;  <span class="comment"># 使用IP地址代替域名</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend_servers;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置文件中，我们将<code>server_name</code>指令设置为Nginx服务器的IP地址<code>192.168.8.171</code>，这样Nginx会根据IP地址匹配到对应的虚拟主机进行处理。</p><p>需要注意的是，如果你想通过公网访问这两台后端服务器，需要将后端服务器的端口号开放到公网，并在防火墙中设置相应的规则。同时，你还需要保证这两台服务器的IP地址是公网可访问的。</p><p>Nginx的负载均衡默认使用的是轮询算法，也可以根据实际情况选择其他算法，例如ip_hash算法、least_conn算法等。另外，在生产环境中，还需要根据实际情况配置Nginx的缓存、超时、错误处理等相关参数，以保证系统的稳定性和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署多项目时的nginx配置</title>
      <link href="/2022/12/20/spring/nginx%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/12/20/spring/nginx%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h1><h2 id="文件夹的摆放"><a href="#文件夹的摆放" class="headerlink" title="文件夹的摆放"></a>文件夹的摆放</h2><ol><li>在linux系统中，在<code>/home</code>目录下创建<code>vc</code> 文件夹，之后所有关于项目的文件都放在此文件夹中</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/vc</span><br></pre></td></tr></table></figure><ol start="2"><li><p>前端修改文件 vue.vonfig.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">publicPath</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;/ra&quot;</span> : <span class="string">&quot;/&quot;</span>,</span><br></pre></td></tr></table></figure></li><li><p>前端修改.env.production文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 若依管理系统/生产环境</span><br><span class="line">VUE_APP_BASE_API = &#x27;/ra-api&#x27;</span><br></pre></td></tr></table></figure></li><li><p>修改router&#x2F;index.js最后几行，增加一个base</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>, <span class="comment">// 去掉url中的#</span></span><br><span class="line">  <span class="attr">base</span>: <span class="string">&quot;/ra/&quot;</span>,</span><br><span class="line">  <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  <span class="attr">routes</span>: constantRoutes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在前端终端输入 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure></li><li><p>在这个文件夹下创建跟项目相关的文件夹</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存放nginx的配置</span></span><br><span class="line">mkdir -p /home/vc/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存放redis的配置</span></span><br><span class="line">mkdir -p /home/vc/redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存放mysql的配置</span></span><br><span class="line">mkdir -p /home/vc/mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在project文件夹存放项目相关文件,在各项目项目的文件中存放网页文件和jar包和配置文件</span></span><br><span class="line">mkdir -p /home/vc/project/ca</span><br><span class="line">mkdir -p /home/vc/project/kms</span><br><span class="line">mkdir -p /home/vc/project/ra</span><br></pre></td></tr></table></figure><ol start="3"><li>各个项目文件的命名</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各项目的html文件不要全部使用dist，不好区分</span><br><span class="line"></span><br><span class="line">ca的html项目命名为ca ，jar包命名为 prod-ca-api.jar , 设置启动在8081端口</span><br><span class="line">ra的html项目命名为ra ，jar包命名为 prod-ra-api.jar , 设置启动在8082端口</span><br><span class="line">kms的html项目命名为ra ，jar包命名为 prod-kms-api.jar , 设置启动在446端口</span><br></pre></td></tr></table></figure><h2 id="nginx配置说明"><a href="#nginx配置说明" class="headerlink" title="nginx配置说明"></a>nginx配置说明</h2><ol><li>拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><ol start="2"><li>把docker内部nginx的配置文件映射到真实物理机上</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/vc/nginx</span><br><span class="line">mkdir -p /home/vc/nginx/conf</span><br><span class="line">mkdir -p /home/vc/nginx/html</span><br><span class="line">mkdir -p /home/vc/nginx/logs</span><br></pre></td></tr></table></figure><ol start="3"><li><p>建临时容器把nginx配置拷贝到物理机上</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name nginxweb -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure></li><li><p>拷贝文件</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginxweb是上面使用name参数命名的容器名称</span></span><br><span class="line">docker cp nginxweb:/etc/nginx/nginx.conf /home/vc/nginx</span><br><span class="line">docker cp nginxweb:/etc/nginx/conf.d /home/vc/nginx/conf</span><br><span class="line">docker cp nginxweb:/usr/share/nginx/html /home/vc/nginx/html</span><br><span class="line">docker cp nginxweb:/var/log/nginx /home/vc/nginx/logs</span><br><span class="line">docker cp nginxweb:/etc/ssl /home/vc/nginx/ssl</span><br></pre></td></tr></table></figure><ol start="5"><li>除临时容器</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop nginxweb</span><br><span class="line">docker rm nginxweb</span><br></pre></td></tr></table></figure><ol start="6"><li>再次创建新的ngixn容器，并挂载文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定要加restart参数，自动重启容器，端口对齐十分重要，80对80不然会有很多bug</span></span><br><span class="line">docker run </span><br><span class="line">--name nginxweb </span><br><span class="line">-p 80:80 </span><br><span class="line">-v /home/vc/nginx/nginx.conf:/etc/nginx/nginx.conf </span><br><span class="line">-v /home/vc/nginx/conf/conf.d:/etc/nginx/conf.d </span><br><span class="line">-v /home/vc/nginx/html:/usr/share/nginx </span><br><span class="line">-v /home/vc/nginx/logs:/var/log/nginx </span><br><span class="line"> --restart=always </span><br><span class="line">-d </span><br><span class="line"> nginx</span><br></pre></td></tr></table></figure><ol start="7"><li>使用软链接把各项目的html文件链接到nginx文件中去</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果遵循我上面的命名规则，这里可以照抄</span></span><br><span class="line">ln -s /home/vc/project/ca/ca /home/vc/nginx/www/ca</span><br><span class="line">ln -s /home/vc/project/ra/ra /home/vc/nginx/www/ra</span><br><span class="line">ln -s /home/vc/project/kms/kms /home/vc/nginx/www/kms</span><br></pre></td></tr></table></figure><ol start="8"><li>nginx配置文件的修改（多项目）</li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不要复制粘贴这个，此处保留用SSL协议后面会用到</span></span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#全局参数设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置nginx启动进程的数量，一般设置成与逻辑cpu数量相同 </span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个nginx进程能打开的最大文件数 , linux也要使用ulimt放开文件访问限制</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定错误日志存放路径</span></span><br><span class="line"><span class="attribute">error_log</span>  logs/<span class="literal">error</span>.log;     </span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx工作模式配置</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 事件驱动类型 ，bsd操作系统使用kqueue , windows下不做指定</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="comment">#最大连接数,如果要改的更大,需要解除linux句柄最大上限</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http 服务相关设置 </span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment">#隐藏Nginx版本信息</span></span><br><span class="line">    <span class="comment">#server_tokens off;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#关联mime类型，关联资源的媒体类型(不同的媒体类型的打开方式)</span></span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#根据文件的后缀来匹配相应的MIME类型</span></span><br><span class="line">    <span class="comment">#写入Response header,让浏览器播放文件而不是下载</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于开启文件高效传输模式，一般设置为on</span></span><br><span class="line">    <span class="comment">#若nginx是用来进行磁盘IO负载应用时,可以设置为off,降低系统负载</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置长连接的超时时间，请求完成之后还要保持连接多久，不是请求时间多久</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#日志的输出格式</span></span><br><span class="line">    <span class="comment">#如需打印请求的body参数信息，可在$body_bytes_sent后添加 $request_body </span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;remote_addr - remote_user [time_local] &quot;request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;status body_bytes_sent &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;http_user_agent&quot; &quot;http_x_forwarded_for&quot;&#x27;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  logs/access.log  main; <span class="comment">#设置日志输出的位置</span></span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">on</span>;  <span class="comment">#是否开启日志，开启on,关闭off</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听的端口，http默认监听端口为80</span></span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">80</span>; </span><br><span class="line">        <span class="comment">#监听的主机名</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost; </span><br><span class="line">        <span class="attribute">charset</span> UTF-<span class="number">8</span>;</span><br><span class="line">        <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时，单位秒)</span></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">        <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时，单位秒)</span></span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">        <span class="comment">#后端服务器数据回传时间(代理发送超时，单位秒)</span></span><br><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 设置重定向 , 不一定对 , 没试过</span></span><br><span class="line">      <span class="attribute">return</span> <span class="number">302</span> /ca;</span><br><span class="line">      </span><br><span class="line">            <span class="comment">#设置请求的头部中主机名为请求的主机名，而不是代理的nginx的主机名</span></span><br><span class="line">            <span class="comment">#proxy_set_header Host $host:$server_port;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#让后端服务器知道是前端哪个设备发送的消息</span></span><br><span class="line">            <span class="comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#获得真实ip , 同上</span></span><br><span class="line">            <span class="comment">#proxy_set_header X-real-ip $remote_addr;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#代理的目标地址,如果要进行负载均衡，目标地址可添test.com</span></span><br><span class="line">            <span class="comment">#proxy_pass http://192.168.68.9:8080;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="section">location</span> ~/ca &#123;</span><br><span class="line">      <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">       <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:8081;</span><br><span class="line">      <span class="comment">#设置跨域</span></span><br><span class="line">      <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,cookietoken,cookieuid&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="section">location</span> ~/ra &#123;</span><br><span class="line">      <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:8082;</span><br><span class="line">        <span class="comment">#设置跨域</span></span><br><span class="line">      <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,cookietoken,cookieuid&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#https配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        //https默认监听端口为443</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        //服务器域名</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">        //设置字符集</span><br><span class="line">        <span class="attribute">source_charset</span> utf-<span class="number">8</span>;</span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        //ssl证书</span><br><span class="line">        <span class="attribute">ssl_certificate</span>      /usr/local/bin/nginx/ssl/wslnginx-cer.crt;</span><br><span class="line"></span><br><span class="line">        //ssl密钥</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>  /usr/local/bin/nginx/ssl/wslnginx-key.key;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#ssl_session_timeout 5m;</span></span><br><span class="line">        <span class="comment">#ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span></span><br><span class="line">        <span class="comment">#ssl_prefer_server_ciphers on;</span></span><br><span class="line"></span><br><span class="line">        //将http请求升级为<span class="attribute">https</span></span><br><span class="line">        error_page <span class="number">497</span> <span class="number">301</span> =<span class="number">307</span> https://<span class="variable">$host</span>:<span class="variable">$server_port</span><span class="variable">$request_uri</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> ~/kms &#123;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:446;</span><br><span class="line">        <span class="comment">#设置跨域</span></span><br><span class="line">      <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,cookietoken,cookieuid&#x27;</span>;</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*\.(css|js|txt|xml|swf|wav)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">    <span class="comment">#最大连接数,如果要改的更大,需要解除linux句柄最大上限</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http 服务相关设置 </span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment">#隐藏Nginx版本信息</span></span><br><span class="line">    <span class="comment">#server_tokens off;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#关联mime类型，关联资源的媒体类型(不同的媒体类型的打开方式)</span></span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#根据文件的后缀来匹配相应的MIME类型</span></span><br><span class="line">    <span class="comment">#写入Response header,让浏览器播放文件而不是下载</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于开启文件高效传输模式，一般设置为on</span></span><br><span class="line">    <span class="comment">#若nginx是用来进行磁盘IO负载应用时,可以设置为off,降低系统负载</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置长连接的超时时间，请求完成之后还要保持连接多久，不是请求时间多久</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#日志的输出格式</span></span><br><span class="line">    <span class="comment">#如需打印请求的body参数信息，可在$body_bytes_sent后添加 $request_body </span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;remote_addr - remote_user [time_local] &quot;request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;status body_bytes_sent &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;http_user_agent&quot; &quot;http_x_forwarded_for&quot;&#x27;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main; #设置日志输出的位置</span></span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">on</span>;  <span class="comment">#是否开启日志，开启on,关闭off</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">absolute_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#监听的端口，http默认监听端口为80</span></span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">80</span>; </span><br><span class="line">        <span class="comment">#监听的主机名</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost; </span><br><span class="line">        <span class="attribute">charset</span> UTF-<span class="number">8</span>;</span><br><span class="line">        <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时，单位秒)</span></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">        <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时，单位秒)</span></span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">        <span class="comment">#后端服务器数据回传时间(代理发送超时，单位秒)</span></span><br><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">            <span class="attribute">index</span> index.html; </span><br><span class="line">      </span><br><span class="line">            <span class="comment">#设置请求的头部中主机名为请求的主机名，而不是代理的nginx的主机名</span></span><br><span class="line">            <span class="comment">#proxy_set_header Host $host:$server_port;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#让后端服务器知道是前端哪个设备发送的消息</span></span><br><span class="line">            <span class="comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#获得真实ip , 同上</span></span><br><span class="line">            <span class="comment">#proxy_set_header X-real-ip $remote_addr;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">         <span class="section">location</span><span class="regexp"> ^~/ca</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">alias</span> /usr/share/nginx/ca/ ;</span><br><span class="line">            <span class="comment">#try_files $uri $uri/ @rewrites;</span></span><br><span class="line">            <span class="attribute">index</span> index.html; </span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /ca/index.html;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="section">location</span> /ca-api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">       <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://192.168.8.170:8081/;</span><br><span class="line">       <span class="comment">#设置跨域</span></span><br><span class="line">       <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,cookietoken,cookieuid&#x27;</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span><span class="regexp"> ^~/ra</span> &#123;</span><br><span class="line">            <span class="attribute">alias</span> /usr/share/nginx/ra/ ;</span><br><span class="line">            <span class="comment">#try_files $uri $uri/ @rewrites;</span></span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /ra/index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /ra-api/ &#123;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://192.168.8.170:8082/;</span><br><span class="line">        <span class="comment">#设置跨域</span></span><br><span class="line">      <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,cookietoken,cookieuid&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span><span class="regexp"> ^~/kms</span> &#123;</span><br><span class="line">            <span class="attribute">alias</span> /usr/share/nginx/kms/ ;</span><br><span class="line">            <span class="comment">#try_files $uri $uri/ @rewrites;</span></span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /kms/index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /kms-api/ &#123;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-real-ip <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://192.168.8.170:8008/;</span><br><span class="line">        <span class="comment">#设置跨域</span></span><br><span class="line">      <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,cookietoken,cookieuid&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="section">location</span><span class="regexp"> ^~/tmp/</span> &#123;</span><br><span class="line">            <span class="attribute">alias</span> /usr/share/nginx/tmp/ ;</span><br><span class="line">            <span class="comment">#try_files $uri $uri/ @rewrites;</span></span><br><span class="line">            <span class="comment">#try_files $uri $uri/ index.html;</span></span><br><span class="line">            <span class="comment">#if (-d $request_filename)&#123;</span></span><br><span class="line">             <span class="comment"># rewrite ^/(.*)([^/])$ $scheme://$host:$port/$1$2/ permanent;</span></span><br><span class="line">            <span class="comment">#&#125;</span></span><br><span class="line">            <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#location @rewrites &#123;</span></span><br><span class="line">            <span class="comment">#rewrite ^/(ra)/(.+)$ /$1/index.html last;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#设置缓存</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*\.(css|js|txt|xml|swf|wav)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单项目（不用这个）</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost # 你的IP地址</span><br><span class="line">    charset utf-8;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">    root  /usr/share/nginx/html/dist;</span><br><span class="line">    try_files $uri $uri/ /index.html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    location /prod-api/ &#123;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_pass http://192.168.8.170:8083/; # 你的IP地址</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">           root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><p>后端启动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar -Duser.timezone=GMT+08 /home/vc/project/ca/prod-ca-api.jar --spring.config.additional-location=/home/vc/project/ca/application.yml&gt;/home/vc/ca.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.11.14 关于回文字符串的二三事</title>
      <link href="/2022/11/14/leetcode/%E5%9B%9E%E6%96%87/"/>
      <url>/2022/11/14/leetcode/%E5%9B%9E%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>以前也写过回文相关的题目，但是当时就是也没讲究怎么做这种题，也没有整理方法，导致周赛的时候36&#x2F;40，和朋友比较了写法，通过debug才发现自己的写法多么的不严谨。特此写一篇关于回文的总结文章，（多为常用方法，目前不包括马拉车方法，个人觉得不太常用，因为马拉车我好像只在回文数看到，而且他也不是最佳解题方法，等之后有兴趣补上）。</p><p>这里写下我做回文串的陋习，因为最近滑动窗口题目做多了，上来就是两个for，从左到右遍历出所有的子字符串，但是因为回文串的特性，要选择由内到外遍历的方法，而不能是从左到右遍历。</p><p>本文涉及的题目有</p><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">6236. 不重叠回文子字符串的最大数目 - 力扣（LeetCode）</a></p><p>涉及的方法有：动态规划、中心扩展法的两种写法。</p><h1 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>何为回文串？简单的理解就是你正着写反着写都一样，举例：<code>level</code>,<code>noon</code>都是回文串</p><h2 id="回文串的长度与中心点"><a href="#回文串的长度与中心点" class="headerlink" title="回文串的长度与中心点"></a>回文串的长度与中心点</h2><p>中心点也就是数排中间的点</p><p>当回文串的长度为奇数时，中心点只有一个</p><p>当回文串的长度为偶数时，中心点会有两个</p><h1 id="一些与回文有关的函数"><a href="#一些与回文有关的函数" class="headerlink" title="一些与回文有关的函数"></a>一些与回文有关的函数</h1><h2 id="验证是否为回文串的简单方法"><a href="#验证是否为回文串的简单方法" class="headerlink" title="验证是否为回文串的简单方法"></a>验证是否为回文串的简单方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindromes</span><span class="params">(<span class="type">char</span>[] array, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> begin + (end-begin)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i]!=array[begin+end-i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>忘记在那道题用到这个方法了，反正不难理解，无非就是前后对应，算到中间，字符串为奇数或者偶数的情况都适合用这个方法</p><h2 id="求回文串的长度"><a href="#求回文串的长度" class="headerlink" title="求回文串的长度"></a>求回文串的长度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; arr[left]==arr[right]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 此处为长度-2；这是因为我们在while的时候多减了一次left，多加了一次right。</span></span><br><span class="line">    <span class="comment">// 实际上为right-left+1-2；</span></span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="回文串的几种解题方法"><a href="#回文串的几种解题方法" class="headerlink" title="回文串的几种解题方法"></a>回文串的几种解题方法</h1><p>前面也提过了，无论用什么方法，遍历的时候一定要从中间开始，往两侧移动</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/solution/">647. 回文子串 题解 - 力扣（LeetCode）</a></p><p>注意的是这种方法用到的空间还挺大的</p><h3 id="题目内容："><a href="#题目内容：" class="headerlink" title="题目内容："></a>题目内容：</h3><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]表示s[i..j]是否回文串，true代表是，flase代表不是</span></span><br><span class="line">        <span class="comment">// 因为j一般大于i，所以实际上只用到矩阵的上三角区域</span></span><br><span class="line">        <span class="comment">// 对角线必定为true</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i)==s.charAt(j)) &#123;</span><br><span class="line">                    <span class="comment">// 这种情况其实就将中心点为一个值和两个值的情况包括进去了</span></span><br><span class="line">                    <span class="comment">// 当为一个值时，也就是对角线，j-i==0，直接为true</span></span><br><span class="line">                    <span class="comment">// 当为两个值，同时满足s.charAt(i)==s.charAt(j)，赋予true</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        res++;</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 由内而外，回文串去头去尾也必为回文串</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123;</span><br><span class="line">                        res++;</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划的方法十分好理解。你可以看做是从矩阵的对角线开始逐渐放上三角计算。这里不做详细讲解</p><h2 id="中间扩展法1"><a href="#中间扩展法1" class="headerlink" title="中间扩展法1"></a>中间扩展法1</h2><p>之所以分1和2，是因为我发现有两种不一样的写法，但是原理是一模一样的，但是第二种写法比第一种写法更具技巧，第一种比第二种更具可读性。</p><p>方法1和方法2的操作分别是：</p><ul><li>将一个中间点和两个中间点的情况分别处理；</li><li>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</li></ul><p>首先讲一下第一种。</p><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode）</a></p><p>借助题目来引入方法</p><h3 id="题目内容：-1"><a href="#题目内容：-1" class="headerlink" title="题目内容："></a>题目内容：</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p> <strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><h3 id="中间扩展法1的题解："><a href="#中间扩展法1的题解：" class="headerlink" title="中间扩展法1的题解："></a>中间扩展法1的题解：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">null</span>||s.length()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 我们要分两种情况得到答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> getLength(s,i,i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> getLength(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;end-start+<span class="number">1</span>)&#123;</span><br><span class="line">                start = i -(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end = i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(String s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处为长度-2；这是因为我们在while的时候多减了一次left，多加了一次right。</span></span><br><span class="line">    <span class="comment">// 实际上为right-left+1-2；</span></span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用了求回文串的长度函数，解法也是十分的可读清晰。与动态规划不同的是，我们需要把中间点是一个的可能性，还有中间点是两个的可能性分别计算一次才能得到答案。</p><h2 id="中间扩展法2"><a href="#中间扩展法2" class="headerlink" title="中间扩展法2"></a>中间扩展法2</h2><p>这个方法比方法1有意思很多，以至于用了它之后我就不想用扩展法1了。扩展法2与扩展法1没什么不同，但是扩展法2从中间点的角度出发，把中间点可能出现的情况都遍历了一次，这样做可以不用区分回文串为奇数偶数两种情况，因此也就不用特定把求长度的函数提取出来，函数整体就显得比较干练。</p><p>我们假设一个长度为4的字符串来分析中间扩展法2的具体步骤：</p><ol><li><p>枚举所有的回文中心</p><p>如下表，我们枚举所有的回文中心，注意的是若左回文中心等于右回文中心时，说明只有一个回文中心。</p><table><thead><tr><th align="center">回文中心编号</th><th align="center">左回文中心（下标）</th><th align="center">右回文中心（下标）</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">6</td><td align="center">3</td><td align="center">3</td></tr></tbody></table><p>因此我们可以得到一个长度为4的字符串，总共有7种回文中心可能，类比到长度为n的字符串，总共有<code>2n-1</code>种回文中心。</p><p>观察并发现规律，我们设左回文中心为<code>l</code>，右回文中心为<code>r</code>，则有</p><p>当编号为<code>i</code>时，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">l = i/<span class="number">2</span>;</span><br><span class="line">r = (i+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">// 有的地方会写成r = l + (i%2); 我觉得没什么区别。</span></span><br></pre></td></tr></table></figure></li><li><p>我们在得到左和右回文中心之后，直接向外扩展即可</p></li></ol><p>我们还是以<a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode）</a>这道题为例子</p><p>给出中间扩展法2的题解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>*n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; arr[l] == arr[r]) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; r-l-<span class="number">1</span>) &#123;</span><br><span class="line">                len = r-l-<span class="number">1</span>;</span><br><span class="line">                start = l+<span class="number">1</span>;</span><br><span class="line">                end = r-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是代码十分干练。</p><h1 id="美团周赛6236"><a href="#美团周赛6236" class="headerlink" title="美团周赛6236"></a>美团周赛6236</h1><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">6236. 不重叠回文子字符串的最大数目 - 力扣（LeetCode）</a></p><p>我们拿这道题作为一个最后总结，用上面三种方法做出题解</p><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPalindromes</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; visited[i]!=<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n &amp;&amp; visited[j]!=<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]==arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == <span class="literal">true</span> &amp;&amp; j-i+<span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;左：&quot;+i);</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;右：&quot;+j);</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i; temp &lt;= j; temp++) &#123;</span><br><span class="line">                        visited[temp] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间扩展法1-1"><a href="#中间扩展法1-1" class="headerlink" title="中间扩展法1"></a>中间扩展法1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">paliAns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPalindromes</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">            bfs(arr,i,i,k);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n&amp;&amp;arr[i]==arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                bfs(arr,i,i+<span class="number">1</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paliAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[start]==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> end-start+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (length &lt; k &amp;&amp; left &gt;= <span class="number">1</span> &amp;&amp; right &lt; n-<span class="number">1</span>) &#123;</span><br><span class="line">           </span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (arr[left]!=arr[right] || visited[left]==<span class="number">1</span> || visited[right]==<span class="number">1</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            length+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (length&gt;=k) &#123;</span><br><span class="line">            paliAns++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间扩展法2-1"><a href="#中间扩展法2-1" class="headerlink" title="中间扩展法2"></a>中间扩展法2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPalindromes3</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// f[i]表示arr[0..i-1]的最大回文字符串数量</span></span><br><span class="line">        <span class="comment">// 初始值f[0]=0;</span></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i / <span class="number">2</span>, r = (i+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">// 中心扩展法</span></span><br><span class="line">            <span class="comment">// l+1为左起点的右边的第一个数。</span></span><br><span class="line">            <span class="comment">// 我们实际上要做到的效果是，随着i的移动，将最大值不断往后覆盖。类似于excel下拉那个功能。</span></span><br><span class="line">            <span class="comment">// 但是我们注意到i的范围是超过n的，所以我们要用线性转换将i转为范围内的数,好让数字随着i的增加能够最大值也能覆盖f[]</span></span><br><span class="line">            <span class="comment">// 很明显我们会发现l和r其实已经是很好的映射了，这两数字都能够走完整个f数组，因此我们取l还是r来更新都可以。</span></span><br><span class="line">            <span class="comment">// 注意在这里我们两个数字都能取，完全是因为l和r要么相等要么只差1,只要达到目的差别不大</span></span><br><span class="line">            <span class="comment">// f[r + 1] = Math.max(f[r],f[r+1]);与f[l + 1] = Math.max(f[l],f[l+1]);，没有什么太大区别</span></span><br><span class="line">            f[r + <span class="number">1</span>] = Math.max(f[r],f[r+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//            f[l + 1] = Math.max(f[l],f[l+1]);</span></span><br><span class="line">            <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s.charAt(l)==s.charAt(r)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                    <span class="comment">// ①、当找到符合题意的最小长度字符串时，我们要更新数量</span></span><br><span class="line">                    <span class="comment">// ②、首先我们可以看到，在这块代码我们是认为arr[l..r]是一个回文字符串.</span></span><br><span class="line">                    <span class="comment">// ③、那么我们首先要得到arr[0..l-1]最大回文字符串为多少并且加一</span></span><br><span class="line">                    <span class="comment">// ④、f[r+1]代表着arr[0..r]的最大回文字符串，</span></span><br><span class="line">                    <span class="comment">// ⑤、根据③我们可以得到公式f[r+1] = f[l]+1</span></span><br><span class="line">                    <span class="comment">// ⑥、我这里没有使用f[r+1] = Math.max(f[r+1],f[l]+1);</span></span><br><span class="line">                    <span class="comment">// 是因为我知道最大值是在前面传递，那么你f[r+1]要么等于被更新到的最大值，要么等于0，所以没必要取最大值（可以通过debug得到）</span></span><br><span class="line"><span class="comment">//                    f[r + 1] = Math.max(f[r + 1], f[l] + 1);</span></span><br><span class="line">                    ans++;</span><br><span class="line">                    f[r+<span class="number">1</span>] = f[l]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l--;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 回文 </tag>
            
            <tag> 动态算法 </tag>
            
            <tag> 中心扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.26 2448.使数组相等的最小开销</title>
      <link href="/2022/10/26/leetcode/zhongweishu/"/>
      <url>/2022/10/26/leetcode/zhongweishu/</url>
      
        <content type="html"><![CDATA[<p>第一次参加周赛，把很多知道概念但是不会写的数学题理了一下，比如说最大公因数，会算但不会写成代码，结果就写的稀巴烂。这一节讲的这一题是跟中位数有关的，做一道题送两道题，因此一块做个整理，让这种题型彻底学会，虽然这题本身也不算很难，但思路在考试的时候有时候确实不容易get到，因此也希望在总结写笔记的时候能获得点心得体会</p><h1 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h1><p>概念懒得概述了，就是将数组排序之后，取中间那个值；如果数组长度为偶数，则取中间两个值的平均数。知道这个概念之后我们就可以讲一下下面这道题。</p><h1 id="462-最小操作次数使数组元素相等-II"><a href="#462-最小操作次数使数组元素相等-II" class="headerlink" title="462. 最小操作次数使数组元素相等 II"></a>462. 最小操作次数使数组元素相等 II</h1><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II - 力扣（LeetCode）</a></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，返回使所有数组元素相等需要的最小操作数。</p><p>在一次操作中，你可以使数组中的一个元素加 <code>1</code> 或者减 <code>1</code> 。</p><p> <strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">只需要两次操作（每次操作指南使一个元素加 1 或减 1）：</span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,10,2,9]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为我提前就知道了这道题可以用中位数做，所以实际上我也不算自己思考出来的，一下子就做出来的，但总的来说这个思路一旦有了，这道题简单得不得了。这道题的答案里面会讲为什么是中位数，而不是任意一个不属于这个数组的值(值得一提的是，当数组长度为偶数的时候，选哪一个值作为答案得到的操作次数都是一样的)。</p><p>惯例先上代码再分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> nums[n/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> Math.abs(nums[i]-mid);</span><br><span class="line">            res+=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为太简单了没加注释，我们使用了sort快速将nums排序好，接着取中间值，并将全部值与中间值相加，叠加次数得到结果。</p><p>这个算法有改进的一点就是：因为我们只需要得到中位数，实际上不需要将数组完全排序，这个时候可能就会有人问，那我不排好序，怎么得到中位数，这不是痴人说梦话吗。还真可以，有两个办法，一个就是堆排序，一个就是快速排序。这个方法在下面这道题提出了。</p><h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h1><h2 id="题目内容-1"><a href="#题目内容-1" class="headerlink" title="题目内容"></a>题目内容</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">通过 partition 减治 + 优先队列（Java） - 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p><strong>示例1</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这道题有三个方法</p><p>第一个方法就是暴力法，先排序然后取排第k大的值，没什么含量，这道题还是中等题，所以肯定不会这么简单</p><p>第二个方法就是快速排序，通过改变快速排序一些小细节，将数组的整体排序，改成查到第k大位置的值就停止计算。</p><p>第三个方法是堆排序，创建一个最小堆，这个堆只会存放k个值，维护队顶，最后通过队顶得到最大值。</p><p>接下来对这几个方法都详细讲一下。第一个方法说实话没什么营养价值，可以锻炼一下写快排，方便第二题改写也挺好的。或者偷懒的话直接写一个sort再简单不过。</p><ol><li><p>方法1：暴力解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[len - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li><li><p>方法2：快排改写（减而治之）</p><p>先上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len-k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码核心，通过while（true）多次调用快速排序，直到达到判断条件，return出我们要的答案。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (partition == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[partition];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (partition &gt; target) &#123;</span><br><span class="line">                right = partition-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (partition &lt; target) &#123;</span><br><span class="line">                left = partition+<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序一般会使用void，但我们的目的是为了获得索引，从而提前结束排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[left];</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="comment">// 原快速排序此块还会使用递归，但我们只需要用到索引</span></span><br><span class="line">        <span class="comment">// partition(nums,start,left-1);</span></span><br><span class="line">        <span class="comment">// partition(nums,left+1,end);</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里面把和快排有区别的地方在注释里标注出来了，实际上发现其实没什么改变，（不过还得说的是快排还是得多写，不然很快就会忘记怎么写的，当然每次捡回来都很快，而且会越来越有新的理解）。可以看到我们通过return一个值，只要他等于<code>len-K</code>的时候，这个索引上的数字就是我们要的答案了。</p></li><li><p>方法三：堆排序（优先队列）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 使用一个含有 k 个元素的最小堆，PriorityQueue 底层是动态数组，为了防止数组扩容产生消耗，可以先指定数组的长度</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, Comparator.comparingInt(a -&gt; a));</span><br><span class="line">        <span class="comment">// Java 里没有 heapify ，因此我们逐个将前 k 个元素添加到 minHeap 里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            minHeap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">topElement</span> <span class="operator">=</span> minHeap.peek();</span><br><span class="line">            <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; topElement) &#123;</span><br><span class="line">                <span class="comment">// Java 没有 replace()，所以得先 poll() 出来，然后再放回去</span></span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><ul><li>我们首先创建一个优先队列（最小堆），并且该堆只能放k个元素。</li><li>堆不满的时候，往堆直接添加</li><li>堆满了，我们只要维护堆顶的值即可，我们将其与还未入堆的值比较。（首先我们要明白的是，堆顶是这个堆最小的值，也就是说已经有K-1个数字比堆顶大了，因此该堆顶最大也只可能是第K大了，更何况后面的数字还没比较）<ul><li>如果比较的值比堆顶小，说明这个值连第K大的资格都没有，直接丢弃，看下一个</li><li>如果比较的值比堆顶大，说明这个值有资格竞争第K大，相反的原堆顶的值这下只可能争取第K+1大了，他已经没有价值留在堆里，我们将其丢弃。之后将新到的值放进最小堆里，丢进去的时候，该堆会动态更新，此时会选举出新的所谓的第K大的值。</li></ul></li></ul></li></ol><p>我们可以看出通过方法二和方法三可以优化462题，更快速找到中位数</p><h1 id="2448-使数组相等的最小开销"><a href="#2448-使数组相等的最小开销" class="headerlink" title="2448. 使数组相等的最小开销"></a>2448. 使数组相等的最小开销</h1><p>这道题是今天要讲的重中之重。这道题是周赛的第三道困难题，前面两道题花了我太多时间，导致我这道题都没开始思考，然后切了个聊天看到我朋友说的思路，我直接写出来了，好家伙这下也不能是我想出来的。</p><h2 id="题目内容-2"><a href="#题目内容-2" class="headerlink" title="题目内容"></a>题目内容</h2><p>给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。</p><p>你可以执行下面操作 任意 次：</p><p>将 nums 中 任意 元素增加或者减小 1 。<br>对第 i 个元素执行一次操作的开销是 cost[i] 。</p><p>请你返回使 nums 中所有元素 相等 的 最少 总开销。</p><p> <strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>], cost = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">14</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：我们可以执行以下操作使所有元素变为 <span class="number">2</span> ：</span><br><span class="line">- 增加第 <span class="number">0</span> 个元素 <span class="number">1</span> 次，开销为 <span class="number">2</span> 。</span><br><span class="line">- 减小第 <span class="number">1</span> 个元素 <span class="number">1</span> 次，开销为 <span class="number">3</span> 。</span><br><span class="line">- 减小第 <span class="number">2</span> 个元素 <span class="number">3</span> 次，开销为 <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">总开销为 <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">8</span> 。</span><br><span class="line">这是最小开销。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], cost = [4,2,8,1,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组中所有元素已经全部相等，不需要执行额外的操作。</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>这道题和<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II </a>的区别无非在于多了一个cost数组维护，很多人可能就想不出来，没做过462题的可能一脸懵。做过462题的人可能有点思路，但可能多过纠结于怎么使用cost数组。稍微转换一次思路，<code>cost[i]</code>可以看成是<code>nums[i]</code>的出现次数，可以说很多同学可能就豁然开朗了，题目瞬间降维维462题了，上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">allCost</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="comment">// 定义一个list把nums和对应的cost绑定在一起，同时记下cost的和。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i],cost[i]&#125;);</span><br><span class="line">            allCost+=cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据nums的大小对list进行排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//取cost和的中间值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">midcost</span> <span class="operator">=</span> allCost/<span class="number">2</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">collectCost</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//函数的目的是为了获得达到中间cost值的i，即“加权中位数”的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            collectCost += list.get(i)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (collectCost&gt;=midcost) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再遍历一遍，将所有值与加权中位数求差并加权计算，得到结果。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> Long.valueOf(Math.abs(nums[i]-list.get(mid)[<span class="number">0</span>]));</span><br><span class="line">            ans+=temp*cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>增加了一个<code>allCost</code>还有<code>midcost</code>，当我们计算到积累的cost  <code>collectCost</code>  大于<code>midcost</code>时，得到<code>nums</code>里的数字，总损耗便出来了</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 中位数 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.23 剑指 Offer II 001. 整数除法</title>
      <link href="/2022/10/23/leetcode/jianzhi2-1/"/>
      <url>/2022/10/23/leetcode/jianzhi2-1/</url>
      
        <content type="html"><![CDATA[<p>这一节笔记主要记录一下位运算怎么在简单的运算能起到提到效率，第一次接触这个概念的时候，还是在一道快速乘的题，要求不使用乘除实现乘法，其实大家都能想到用加法然后for循环也能达到乘法的结果，但是这样的复杂度会达到O（n）级别，但如果能转换为二进制，同时引入位运算，效率将会极大提高，这里先引入快速乘的模板好做讲解。</p><h1 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ksc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处等价于（b%2==1）</span></span><br><span class="line">            <span class="keyword">if</span> ((b&amp;<span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res+=a;</span><br><span class="line">            &#125;</span><br><span class="line">            a+=a;</span><br><span class="line">            <span class="comment">// 此处等同于b/2</span></span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一次看代码我是十分懵逼的，但实际上从二进制角度又十分好理解，举个例子a&#x3D;5，b&#x3D;49，代码的逻辑如下</p><ol><li>将数字b转换为二进制，b&#x3D;110001</li><li>看二进制数字的末位是1还是0，代码中<code>(b&amp;1) != 0</code>就是为此做判断<ul><li>是1的情况：说明之后二进制在右移时会把1抛弃掉，同时也代表着该数除以2的余数为奇数，这个时候我们要把多出来的数特别的加回去，也就是<code>res+=a</code></li><li>是0的情况：不做处理</li></ul></li><li><strong>这一步和第四步没有先后顺序，可以颠倒</strong>，因为要将b右移了，此时a的大小要翻一倍，即  <code>a+=a</code></li><li>b右移，直至b为0，重复2到4步。</li></ol><p>仅仅这么描述挺生涩的，这里用另一个角度助于理解，就是从一开始for循环一个b，也就是（a+a+a+…+a)加b次，按前面的例子就是a加49次。改变为二进制就变成了（a×32）+（a×16）+ （a×1），是不是就明白了，实际上就是将49&#x3D;32+16+1，也就是二进制数字上（110001）的三个1代表的二进制转为十进制大小32、16、1，因此第三步a大小翻倍以及第二步只看1就可以理解了。</p><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>首先上个原题，这道题实际上用的方法和上面没区别。只不过我们在做题目的时候，往往要考虑的还有符号以及范围。</p><p>在幂函数里面如果指数&lt;0的时候，我们要将指数转换为正数，转换方法为<br>$$<br>a^b &#x3D;  ({1 \over a} ) ^ {-b}<br>$$<br><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n) - 力扣（LeetCode）</a></p><p>上题为快速幂的题，同样我们先上题解，再使其与上面快速乘的题解作对比</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            n=-n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 区别1</span></span><br><span class="line">                res*=x;</span><br><span class="line">            &#125;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//区别2</span></span><br><span class="line">            x*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码与快速乘的代码相比，除去考虑符号的代码块，只有两个区别，两个区别其实就是把**+<strong>改为了</strong>×**，如果说多个数字相加就是乘法，理所当然的多个乘法就是幂运算了</p><h1 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h1><p>在介绍完前面的快速乘快速幂，我们开始讲这一道题——整数除法，乘法用加法代替，那么理所当然除法就要用减法代替，但是这道题还得考虑范围问题，就显得比较麻烦。先放题解。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 32 位最大值：2^31 - 1 = 2147483647</span></span><br><span class="line">        <span class="comment">// 32 位最小值：-2^31 = -2147483648</span></span><br><span class="line">        <span class="comment">// -2147483648 / (-1) = 2147483648 &gt; 2147483647 越界了</span></span><br><span class="line">        <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> (a &gt; <span class="number">0</span>)^(b &gt; <span class="number">0</span>) ? -<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 首先，右移的话，再怎么着也不会越界</span></span><br><span class="line">            <span class="comment">// 其次，无符号右移的目的是：将 -2147483648 看成 2147483648</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，这里不能是 (a &gt;&gt;&gt; i) &gt;= b 而应该是 (a &gt;&gt;&gt; i) - b &gt;= 0</span></span><br><span class="line">            <span class="comment">// 这个也是为了避免 b = -2147483648，如果 b = -2147483648</span></span><br><span class="line">            <span class="comment">// 那么 (a &gt;&gt;&gt; i) &gt;= b 永远为 true，但是 (a &gt;&gt;&gt; i) - b &gt;= 0 为 false</span></span><br><span class="line">            <span class="keyword">if</span> ((a&gt;&gt;&gt;i)-b&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                a-=(b&lt;&lt;i);</span><br><span class="line">                <span class="comment">//res一旦超出范围直接returrnInteger.MIN_VALUE</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE - (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                res+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span>?res:-res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题用一种比较巧妙的方式，使得空间和时间复杂度都是常量级别，注释来自<a href="https://leetcode.cn/problems/xoh6Oh/solution/jian-dan-yi-dong-javac-pythonjs-zheng-sh-e8r6/">简单易懂Java&#x2F;C++ &#x2F;Python&#x2F;js&#x2F;go - 整数除法(剑指) - 整数除法 - 力扣（LeetCode）</a>，感谢大佬的题解。前面几行很好理解，主要就是对符号进行判断，for里面使用的思路与快速乘快速减无异，与快速乘从小加到大相反，快速减是从大减到小。一般在范围内，便做一次减法运算，更新res值。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.9 剑指59题——从单调栈的思维下手</title>
      <link href="/2022/10/09/leetcode/jianzhi59/"/>
      <url>/2022/10/09/leetcode/jianzhi59/</url>
      
        <content type="html"><![CDATA[<p>​发现最近做题常做常新，果然还是得靠积累，以前每天做题都感觉每天都是新的知识点，完全不知道这知识点怎么用。但是做多了发现有好多种解法有既视感，感觉有了整理解法的资本，上次整理了位运算相关的知识，这里整理一下单调栈的知识，顺便审视一下自己做题的一个错误解法。</p><h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定一个数组 <em>nums</em> 和滑动窗口的大小 <em>k</em>，请找出所有滑动窗口里的最大值。</p><p><strong>输入</strong>：nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</p><p><strong>输出</strong>：[3,3,5,5,6,7] </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">-------------------------     -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h1 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h1><h2 id="最大堆vs单调栈"><a href="#最大堆vs单调栈" class="headerlink" title="最大堆vs单调栈"></a>最大堆vs单调栈</h2><p>这题一出来，我第一个思路就是使用优先队列（最大堆），毕竟用现成的对象和封装好的方法，可以实现维护一个长度为k的堆，滑动窗口每新增一个便丢进堆里排序，左侧移出窗口可以使用remove(Object o)直接删除堆里要素，但很明显这是一个超时的做法，下面附上解题代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxqueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            maxqueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k-<span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == k-<span class="number">1</span>) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = maxqueue.peek();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxqueue.remove(nums[i-k]);</span><br><span class="line">            maxqueue.offer(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = maxqueue.peek();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​我们知道最大堆实际上就是完全二叉树维护的，无论是查找还是新增都需要一定的时间和空间复杂度，而且k个元素是一直需要维护的，k越大空间复杂度高时间复杂度自然也高。因此需要寻找其他解法，这个时候就要提一下单调栈的概念了，也就是本题的一个优解。单调栈只需要比较栈顶就可以实现获得最小值的效果，这比最大堆好太多。</p><p>​引入单调栈这个概念，先介绍一道使用了单调栈解法的题，也就是最经典的题目<a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a>接雨水题，这道题我其实很喜欢空间换时间的解法，也就是维护两个数组的解法并且优化为双指针解法，这里不做赘述，仅提示该题并不只有一种解法。</p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>何为单调栈？概念其实很简单，单调栈就是单调递增、单调递减的栈。</p><p><strong>单调栈的作用：</strong>把序列中每个元素放到单调栈中进行维护就可以在 <em>O</em>(<em>n</em>) 的时间复杂度内求出区间每个元素为最大值&#x2F;最小值时。</p><p>单调栈插入模板（以单调递减栈为例）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// insert element x in mono_stack</span><br><span class="line">void insert(stack&lt;int&gt;&amp; mono_stack, int x) &#123;</span><br><span class="line">// operations #1</span><br><span class="line">    // 当栈非空且栈顶元素小于等于当前元素时，出栈,这是因为只保存递减部分，递增不保留。</span><br><span class="line">while (!mono_stack.empty() &amp;&amp; mono_stack() &lt; x) &#123;</span><br><span class="line">  mono_stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">// operations #2</span><br><span class="line">mono_stack.push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​他的实现可以说是十分简单，但停留于此是不够的，我们应该学会这个方法什么时候能使用，要怎么改用使其符合我们的题意。</p><p>​首先我们把代码分成两个部分，操作1（operation1）还有操作2（operation2），操作2为入栈操作，操作1为出栈操作。其中操作2是必定执行的，也就是每次都会把值放进栈里面，而操作1是可选操作的，这也保证了不会出现<strong>空指针异常</strong>。大部分的修改模板操作都在操作1这个while里面，我愿称操作1为代码的核心代码。操作1的意思便是当栈非空，且我们遇到比栈顶大的值x，便把栈顶抛掉，继续判断下一个栈顶是不是比x小，我们不断抛弃比x小的值，最后放进x作为新的栈顶。从这个现象我总结了两条单调递减栈的现象或者说规律，可以用做做题的思路。单调递增同理可推，故不做累述。</p><ol><li><p><strong>栈顶是这个栈的最小元素。</strong>那是因为我们在操作1每次都会抛弃掉比新来的值小的值，这样就保证了栈中的所有值只可能比栈顶大，不可能比栈顶小。</p></li><li><p><strong>单调递减栈本质上是极大值与极大值的比较</strong>。该情况出现在有多个极大值的情况，我说的这个现象确实是很少人会去观察的点，故先做这个归纳。什么叫做极大值与极大值比较呢。首先我们要明白极大值，也就是左侧递增，右侧递减，该处导数为0的一个函数值（数学概念已经基本忘光可能不严谨，请结合自己的数学知识理解即可）。首先根据单调递减栈的特性，第一个保留在栈底比较久的值我们完全可以判断为第一个极大值，因为第一个极大值前的值基本不会得到保留，只会被不断的抛出更新。接着我们根据两个极大值一般分成两种情况</p><ul><li><strong>第一个极大值小于第二个极大值</strong>：在这种情况下为了保证单调递减栈的特性，第二个极大值前面所有的值都会被抛出，第二个极大值将会取代上一个极大值的位置。我愿称之为极值更新。</li><li><strong>第一个极大值大于或者等于第二个极大值</strong>：在这种情况下，两个极值之间形成的凹处的值都会被抛弃（递减部分不会被抛出），但第一个极大值不会被抛出，它仍然会保存在栈里，此时将新的极大值加入。</li><li><strong>只有递减部分得到保留入栈，这也是单调递减栈中“递减“两个字的真正含义</strong></li></ul><p>当然上面的情况仅存在于while条件为模板的情况下，所以修改while条件判断就不一定是单调递减栈了，故谨慎改用此处。</p></li></ol><p>​第一个规律可以说基本上没什么用，这是简单的不能再简单的规律，但是至少要学会根据第一个规律，实现单调栈代码。比较重要的还得是第二个规律。与求一堆值的最大值用到优先队列，最大堆不同，单调栈更加关注只取其中的最小值或者最大值，更加关注变化性。<br>        既然极大值都提到了，那么凹函数什么的想必也能想象得到，没错接雨水这道题用的正是第二个规律。我们本身就是求凹处的值，那么需要比较的就是两个极大值，该题的变种在于我们往栈保存的是数组的标签，计算宽度和高度求面积，思路懂了，这道题几乎迎刃而解，放个接雨水题解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="type">int</span> <span class="variable">currWidth</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currHeight</span> <span class="operator">=</span> Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>​终于我们可以回归到本文的题目，我们在接雨水这道题需要知道两个极值，需要知道抛出的值，因此使用单调栈十分完美。而在滑动窗口这道题，我们加入了一个新的机制，取出值，在单调栈中我们只需要不断的入栈，然后将不符合操作1while条件的值抛出去，概括一下，这里有一个点，栈的规律先到的值永远只会在栈底，后到的值只可能把他抛出或者堆在栈底的上面。但是移动窗口这道题，随着窗口的移动，我们要<strong>把先到的极大值丢掉</strong>，很明显栈这个结构是实现不了。</p><p>​聪明的人肯定想到了，栈不行那我可以用队列啊，没错单调队列便是这么个效果。因此我们可以使用单调队列来维护窗口的最大值，将“过气”（不在窗口）的极大值抛出去。其实也就把栈的另一个口打开，因为两个口都能抛出值，因此我们使用双向队列（Deque）来实现单调队列。此时，栈顶成了队头，栈尾成了队尾。这个解法很明显相对最大堆，我们可以抛弃超级多凹处的值，并且还只需要和队尾比较即可，空间和时间复杂度都极大降低。</p><p>​题目已经显而易见，我们只要每次都弹出极大值即可。最后放出该题题解</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 双向队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 形成窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 当数组递增，很明显靠前的最小值都会被淘汰，并且不值得保存，我们只取极大值放进队列。</span></span><br><span class="line">            <span class="comment">// 数组的递增可以扩展到两个峰值的递增，我们只保留右侧较大峰</span></span><br><span class="line">            <span class="comment">// 具体操作为删除上一个最小值</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放进第一个值</span></span><br><span class="line">        res[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="comment">// 移动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 最大值要出栈</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i-k] == deque.peekFirst()) &#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.2 剑指56题</title>
      <link href="/2022/10/02/leetcode/jianzhi56/"/>
      <url>/2022/10/02/leetcode/jianzhi56/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例1</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><h2 id="解法讲解及心得"><a href="#解法讲解及心得" class="headerlink" title="解法讲解及心得"></a>解法讲解及心得</h2><p>这题可以说是leetcode136题的进阶版<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p>同时也不得不让人感慨位运算的神奇，位运算可以用来做快速幂计算，同时还可以用在树状数组还有本题的查找不同的题目中。</p><p>在讲这道题之前想先记下有意思的几种位运算的方法</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或 ^"></a>异或 ^</h3><p>异或运算有以下三个性质。</p><ol><li>任何数和 00 做异或运算，结果仍然是原来的数，即a⊕0&#x3D;a</li><li>任何数和其自身做异或运算，结果是 0，即 a⊕a&#x3D;0</li><li>异或运算满足交换律和结合律，即 a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b</li></ol><p>可以看到这个异或运算在寻找只出现一次的数字，能起到关键作用，我们只需要将数组从头异或到最后，便可以得到我们的答案。</p><h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>lowbit这个概念我是从树状数组知道的，树状数组是一个求前缀和和单点更新的数组，查找和更新的概率都是O（logn），但这类数组实际上除了特定题，我觉得一般很少看到，暂时做了解即可，它出现在<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/?favorite=xb9nqhhg">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a>可以从这道题了解树状数组的用法。</p><p>言归正传，我们假设一个数字x，lowbit运算为x&amp;（-x）这个运算可以得到x二进制表示中最后的“1”，这确实十分神奇，为什么不需要知道，知道他能实现这个效果就行，比如010100经过lowbit运输为000100；</p><p>在了解完这两个解题技巧之后，我们开始正式讲这道题的解法：</p><ol><li><strong>我们首先对整个数组进行异或运算，如下公式：</strong></li></ol><p><em>a</em>⊕<em>a</em>⊕<em>b</em>⊕<em>b</em>⊕…⊕<em>x</em>⊕<em>y</em></p><p>&#x3D;0⊕0⊕…⊕<em>x</em>⊕<em>y</em></p><p>&#x3D;<em>x</em>⊕<em>y</em></p><p>&#x3D;ret</p><p>很明显我们会发现这样没办法得到两个数字，而是得到他们的异或。但是巧妙的地方就在于我们知道x和y是必不相等的，所以他们两的异或得到的二进制的值必然不为0，于是有了下面的步骤</p><ol start="2"><li><strong>对ret进行lowbit运算</strong></li></ol><p>我们已经知道了ret不为0，然后我们使用lowbit能得到ret最靠后的“1”，那么这代表什么呢？</p><p>这代表x和y的二进制表达在这一位上他们是不一样的，要么x在这一位上为0，y为1；要么相反x在这一位上是1，y为0。</p><p>div&#x3D;ret&amp;（-ret）</p><p>有了这样的运算之后，我们看第三个步骤</p><ol start="3"><li><strong>对原数组进行分组计算</strong></li></ol><p>这一步简直是神来之笔，只能说没做过这类型的题简直不可能想出这个方法，有天赋的人除外了。</p><p>我们这一步要做到两个效果</p><ul><li>相同的数字必定在一组</li><li>返回的两个不同数字必定在不同的组</li></ul><p>我们通过lowbit运算之后得到的div，也就是最靠后的“1”的数字，用来和数组中的所有数进行与（&amp;）运算，将这一位上与div相同的分到一组，不相同的分到另一组。很明显，我们已经巧妙的将两个不同数字分开的同时，将相同的数字放到了一组。最后我们能得到两个数字，这便是题目要的答案</p><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 我们首先对整个数组进行异或运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ret ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对ret进行lowbit运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> ret &amp; (-ret);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对原数组进行分组计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div&amp;num)==<span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.9.16 剑指43题</title>
      <link href="/2022/09/16/leetcode/jianzhi43/"/>
      <url>/2022/09/16/leetcode/jianzhi43/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5</p><p><strong>示例1：</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt; 2^31</code></li></ul><h2 id="解法讲解："><a href="#解法讲解：" class="headerlink" title="解法讲解："></a>解法讲解：</h2><p>该题十分独特所以放上来记录一下</p><p>如果玩过行李箱那个密码锁能很好理解，没玩过也无所谓。</p><p>我们常见的最暴力的解法就是从1遍历到n，这是效率十分低下的解法。</p><p>但如果仔细观察规律，通过计算每一个位置在1~n里面出现1的次数，最后再将所有位置数到1的数量追加起来就可以得到最终结果</p><p>举个例子讲解一下：</p><p>拿24x5做例子</p><p>其中x为我们锁定的位置<strong>cur</strong></p><p>24为高位<strong>high</strong></p><p>5为低位<strong>low</strong></p><p>我们可以用digit表示我们目前锁定的位置<strong>digit</strong>（当前digit&#x3D;10）</p><p>我们开始计算十位的数量</p><ol><li>当十位为0时，那么也就是说1不可能出现在2410之后，所以实际上只有<strong>0010~2319</strong>这段数字区间十位会出现1，我们暂时把十位遮掉，可以发现变成了计算<strong>000~239</strong>的总数量，也就是240；（归纳：当锁定位置为0时，只看高位数量）</li><li>当十位为1，那么出现1的次数很明显会比第一个情况有所增加，这个时候<strong>0010~2415</strong>这段区间十位会出现1，同样遮掉十位数，这下变成了<strong>000~245</strong>的总数量，总共为246；（归纳：当锁定位置为1时，要同时看高低位数量）</li><li>当十位&gt;1时，和上面一样的推理，这个时候区间就会变成<strong>0010~2419</strong>这个区间，这是因为当十位数大于1时，假设为2，小于2420这个数字且十位数为1的最大数字为2419，遮掉十位数，求<strong>000~249</strong>，总共为250；（归纳：当锁定位置大于1时，只看高位数量，（高位+1）*10）</li></ol><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (high!=<span class="number">0</span>||cur!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur==<span class="number">0</span>) &#123;</span><br><span class="line">                res += high*digit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur==<span class="number">1</span>) &#123;</span><br><span class="line">                res += high*digit+low+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (high+<span class="number">1</span>)*digit;</span><br><span class="line">            &#125;</span><br><span class="line">            digit*=<span class="number">10</span>;</span><br><span class="line">            low = cur*digit+low;</span><br><span class="line">            cur = high%<span class="number">10</span>;</span><br><span class="line">            high = high/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud中nacos config的一些坑</title>
      <link href="/2022/06/29/spring/nacosconfig/"/>
      <url>/2022/06/29/spring/nacosconfig/</url>
      
        <content type="html"><![CDATA[<p>我在弄nacos config按照网上的流程打了一遍，发现并没有在日志弹出配置文件的名字，可能是版本的问题<br>解决方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后便能在控制台的日志看到<br><img src="https://s3.bmp.ovh/imgs/2022/06/29/c0f28361f6dbe63e.png" alt="img"><br>无视第三行，直接看第二行nacos相关的，复制gulimall-coupon.properties即可</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.15 77题</title>
      <link href="/2022/05/15/leetcode/77/"/>
      <url>/2022/05/15/leetcode/77/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfsa(res,list,n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsa</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list,<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> begin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size()==k) &#123;</span><br><span class="line">            List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">            res.add(list1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            dfsa(res,list,n,k,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感谢"><a href="#做题感谢" class="headerlink" title="做题感谢"></a>做题感谢</h1><p>回溯法这类题做多了十分简单</p><p>在for那里，设置begin有点学问，可以多试试</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.13 108题</title>
      <link href="/2022/05/13/leetcode/108/"/>
      <url>/2022/05/13/leetcode/108/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="img"></p><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> travel(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">travel</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = travel(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = travel(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><p>首先是递归函数的参数，因为我们需要用到多的参数，所以我们要重新定义一个递归函数出来。</p><p>其他的与普通递归函数无异。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.9 669题</title>
      <link href="/2022/05/09/leetcode/669/"/>
      <url>/2022/05/09/leetcode/669/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><p>树中节点数在范围 [1, 104] 内</p></li><li><p>0 &lt;&#x3D; Node.val &lt;&#x3D; 104</p></li><li><p>树中每个节点的值都是 唯一 的</p></li><li><p>题目数据保证输入是一棵有效的二叉搜索树</p></li><li><p>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 104</p></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val&lt;low) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val&gt;high) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><p>这可能是我最近做的最糟糕的一题，其实本题并不难，看了解法逻辑十分清晰。</p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/image-20220509105537316.png" alt="imgae12"></p><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><pre><code>    TreeNode</code></pre><p><strong>（2）确定终止条件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>（3）确定单层递归的逻辑</strong></p><p>ps：<strong>注意这里我本来以为和450题一样，修剪就行，但实际上修剪一次和修剪多次是不一样了，所以解法大不相同。</strong></p><p>​如果root（当前节点）的元素小于左边界low的数值，那么应该递归右子树，并返回右子树符合条件的头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val&lt;low) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​如果root（当前节点）的元素大于左边界high的数值，那么应该递归左子树，并返回左子树符合条件的头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val&gt;high) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​接下来将下一层递归处理左子树的结果赋值给root.left、处理右子树的结果赋值给root.right，最后返回root节点，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root.left = trimBST(root.left,low,high);</span><br><span class="line">root.right = trimBST(root.right,low,high);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.7 450题</title>
      <link href="/2022/05/07/leetcode/450/"/>
      <url>/2022/05/07/leetcode/450/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt="img"></p><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 [0, 104].</li><li>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</li><li>节点值唯一</li><li>root 是合法的二叉搜索树</li><li>-105 &lt;&#x3D; key &lt;&#x3D; 105</li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">         <span class="comment">//情况一找不到该节点，返回root</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">//情况二，该节点左右孩子均为空，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//情况三，左孩子为空，右孩子不为空</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span> )</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="comment">//情况四，右孩子为空，左孩子不为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right==<span class="literal">null</span> )</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">//情况五，左右孩子都不为空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right; <span class="comment">// 首先找到删除节点的右子树</span></span><br><span class="line">                <span class="comment">//找到右子树中最小的数字</span></span><br><span class="line">               <span class="keyword">while</span> (cur.left!=<span class="literal">null</span>) &#123; </span><br><span class="line">                   cur =cur.left;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将原本的左子树拼接上去</span></span><br><span class="line">                cur.left=root.left;</span><br><span class="line">               <span class="comment">// 取代root</span></span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right,key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><pre><code>    TreeNode</code></pre><p><strong>（2）确定终止条件</strong></p><pre><code>    即遍历到null的时候</code></pre><p><strong>（3）确定单层递归的逻辑</strong></p><p>主要分析五种情况</p><ul><li>第一种情况：没有找到删除的节点</li><li>找到了删除的节点<ul><li>第二种情况：该节点左右孩子都为空。</li><li>第三种情况：被删除的节点左孩子为空，右孩子不为空。</li><li>第四种情况：被删除的节点右孩子为空，左孩子不为空。</li><li>第五种情况：被删除的节点左右孩子都不为空。</li></ul></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//情况一找不到该节点，返回root</span><br><span class="line">      if (root == null) return root;</span><br><span class="line">      if (root.val == key) &#123;</span><br><span class="line">          //情况二，该节点左右孩子均为空，返回null</span><br><span class="line">          if (root.left==null &amp;&amp; root.right==null)return null;</span><br><span class="line">          //情况三，左孩子为空，右孩子不为空</span><br><span class="line">          if (root.left==null )</span><br><span class="line">              return root.right;</span><br><span class="line">          //情况四，右孩子为空，左孩子不为空</span><br><span class="line">          else if (root.right==null )</span><br><span class="line">              return root.left;</span><br><span class="line">          //情况五，左右孩子都不为空</span><br><span class="line">          else &#123;</span><br><span class="line">             TreeNode cur = root.right; // 首先找到删除节点的右子树</span><br><span class="line">              //找到右子树中最小的数字</span><br><span class="line">             while (cur.left!=null) &#123; </span><br><span class="line">                 cur =cur.left;</span><br><span class="line">             &#125;</span><br><span class="line">             //将原本的左子树拼接上去</span><br><span class="line">              cur.left=root.left;</span><br><span class="line">             // 取代root</span><br><span class="line">              root = root.right;</span><br><span class="line">              return root;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.6 701题</title>
      <link href="/2022/05/06/leetcode/701/"/>
      <url>/2022/05/06/leetcode/701/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果。</p><p><strong>示例1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt="img"></p><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中的节点数将在 [0, 104]的范围内。</p></li><li><p>-108 &lt;&#x3D; Node.val &lt;&#x3D; 108</p></li><li><p>所有值 Node.val 是 独一无二 的。</p></li><li><p>-108 &lt;&#x3D; val &lt;&#x3D; 108</p></li><li><p>保证 val 在原始BST中不存在。</p></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感谢"><a href="#做题感谢" class="headerlink" title="做题感谢"></a>做题感谢</h1><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><p>​TreeNode</p><p><strong>（2）确定终止条件</strong></p><p>​即遍历到null的时候</p><p><strong>（3）确定单层递归的逻辑</strong></p></li></ol><p></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">&#125;</span><br><span class="line">if (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置说明</title>
      <link href="/2022/05/05/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/05/05/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、每次修改config.yml文件之后要先使用hexo server修改配置并查看预览。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>2、预览无问题之后，上传到github</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;作出的修改&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>3、同步到github托管</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>4、当出现如下图的error时</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">fatal: <span class="title">unable</span> <span class="title">to</span> <span class="title">access</span> &#x27;<span class="title">https</span>://<span class="title">github.com</span>/<span class="title">yu1147</span>/<span class="title">blog.git</span>/&#x27;: <span class="title">OpenSSL</span> <span class="title">SSL_read</span>: <span class="title">Connection</span> <span class="title">was</span> <span class="title">reset</span>, <span class="title">errno</span> 10054</span></span><br></pre></td></tr></table></figure><p>输入下面指令即可</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>5、当出现timeout错误的时候，还可以使用下面的指令</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/05/05/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/05/05/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shu.pension.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About me</title>
      <link href="/2022/05/05/%E7%BD%AE%E9%A1%B6%E9%A1%B5/aboutme/"/>
      <url>/2022/05/05/%E7%BD%AE%E9%A1%B6%E9%A1%B5/aboutme/</url>
      
        <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>我是陈诗杰。目前上海大学就读研究生在读。主要钻研后端开发。</p><h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1><ul><li>掌握Java语言以及面向对象设计思想，具有扎实的Java编程功底和编码规范。</li><li>掌握MyBatis、Spring boot等主流框架，能够使用SpringAOP实现数据权限日志管理功能。</li><li>掌握MySQL关系型数据库，对事务、锁、索引、日志有一定的了解</li><li>掌握Redis非关系型数据库，对其底层数据结构和应用场景有一定的了解</li><li>熟悉Linux、Docker指令，会使用Dokcerfile定制化容器，并使用docker-compose快速编排容器</li><li>熟悉IDEA、Git、Maven开发工具</li><li>了解RabbitMQ消息队列，会使用RabbitMQ做简单的削峰</li><li>了解HTML、CSS、JavaScript，了解vue前端框架，使用vue做简单的前端界面。</li></ul><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>qq：1147669839</p><p>微博：@学徒型谕桑</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=5718170&bvid=BV19s411C77T&cid=9285393&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0; " sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/04/hello-world/"/>
      <url>/2022/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
