<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022.10.26 2448.使数组相等的最小开销</title>
      <link href="/2022/10/26/leetcode/zhongweishu/"/>
      <url>/2022/10/26/leetcode/zhongweishu/</url>
      
        <content type="html"><![CDATA[<p>第一次参加周赛，把很多知道概念但是不会写的数学题理了一下，比如说最大公因数，会算但不会写成代码，结果就写的稀巴烂。这一节讲的这一题是跟中位数有关的，做一道题送两道题，因此一块做个整理，让这种题型彻底学会，虽然这题本身也不算很难，但思路在考试的时候有时候确实不容易get到，因此也希望在总结写笔记的时候能获得点心得体会</p><h1 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h1><p>概念懒得概述了，就是将数组排序之后，取中间那个值；如果数组长度为偶数，则取中间两个值的平均数。知道这个概念之后我们就可以讲一下下面这道题。</p><h1 id="462-最小操作次数使数组元素相等-II"><a href="#462-最小操作次数使数组元素相等-II" class="headerlink" title="462. 最小操作次数使数组元素相等 II"></a>462. 最小操作次数使数组元素相等 II</h1><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II - 力扣（LeetCode）</a></p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，返回使所有数组元素相等需要的最小操作数。</p><p>在一次操作中，你可以使数组中的一个元素加 <code>1</code> 或者减 <code>1</code> 。</p><p> <strong>示例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">只需要两次操作（每次操作指南使一个元素加 1 或减 1）：</span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,10,2,9]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为我提前就知道了这道题可以用中位数做，所以实际上我也不算自己思考出来的，一下子就做出来的，但总的来说这个思路一旦有了，这道题简单得不得了。这道题的答案里面会讲为什么是中位数，而不是任意一个不属于这个数组的值(值得一提的是，当数组长度为偶数的时候，选哪一个值作为答案得到的操作次数都是一样的)。</p><p>惯例先上代码再分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> nums[n/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> Math.abs(nums[i]-mid);</span><br><span class="line">            res+=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为太简单了没加注释，我们使用了sort快速将nums排序好，接着取中间值，并将全部值与中间值相加，叠加次数得到结果。</p><p>这个算法有改进的一点就是：因为我们只需要得到中位数，实际上不需要将数组完全排序，这个时候可能就会有人问，那我不排好序，怎么得到中位数，这不是痴人说梦话吗。还真可以，有两个办法，一个就是堆排序，一个就是快速排序。这个方法在下面这道题提出了。</p><h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h1><h2 id="题目内容-1"><a href="#题目内容-1" class="headerlink" title="题目内容"></a>题目内容</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">通过 partition 减治 + 优先队列（Java） - 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p><strong>示例1</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这道题有三个方法</p><p>第一个方法就是暴力法，先排序然后取排第k大的值，没什么含量，这道题还是中等题，所以肯定不会这么简单</p><p>第二个方法就是快速排序，通过改变快速排序一些小细节，将数组的整体排序，改成查到第k大位置的值就停止计算。</p><p>第三个方法是堆排序，创建一个最小堆，这个堆只会存放k个值，维护队顶，最后通过队顶得到最大值。</p><p>接下来对这几个方法都详细讲一下。第一个方法说实话没什么营养价值，可以锻炼一下写快排，方便第二题改写也挺好的。或者偷懒的话直接写一个sort再简单不过。</p><ol><li><p>方法1：暴力解法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[len - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li><li><p>方法2：快排改写（减而治之）</p><p>先上代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len-k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码核心，通过while（true）多次调用快速排序，直到达到判断条件，return出我们要的答案。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (partition == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[partition];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (partition &gt; target) &#123;</span><br><span class="line">                right = partition-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (partition &lt; target) &#123;</span><br><span class="line">                left = partition+<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序一般会使用void，但我们的目的是为了获得索引，从而提前结束排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[start] = nums[left];</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="comment">// 原快速排序此块还会使用递归，但我们只需要用到索引</span></span><br><span class="line">        <span class="comment">// partition(nums,start,left-1);</span></span><br><span class="line">        <span class="comment">// partition(nums,left+1,end);</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里面把和快排有区别的地方在注释里标注出来了，实际上发现其实没什么改变，（不过还得说的是快排还是得多写，不然很快就会忘记怎么写的，当然每次捡回来都很快，而且会越来越有新的理解）。可以看到我们通过return一个值，只要他等于<code>len-K</code>的时候，这个索引上的数字就是我们要的答案了。</p></li><li><p>方法三：堆排序（优先队列）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 使用一个含有 k 个元素的最小堆，PriorityQueue 底层是动态数组，为了防止数组扩容产生消耗，可以先指定数组的长度</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, Comparator.comparingInt(a -&gt; a));</span><br><span class="line">        <span class="comment">// Java 里没有 heapify ，因此我们逐个将前 k 个元素添加到 minHeap 里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            minHeap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 看一眼，不拿出，因为有可能没有必要替换</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">topElement</span> <span class="operator">=</span> minHeap.peek();</span><br><span class="line">            <span class="comment">// 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; topElement) &#123;</span><br><span class="line">                <span class="comment">// Java 没有 replace()，所以得先 poll() 出来，然后再放回去</span></span><br><span class="line">                minHeap.poll();</span><br><span class="line">                minHeap.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><ul><li>我们首先创建一个优先队列（最小堆），并且该堆只能放k个元素。</li><li>堆不满的时候，往堆直接添加</li><li>堆满了，我们只要维护堆顶的值即可，我们将其与还未入堆的值比较。（首先我们要明白的是，堆顶是这个堆最小的值，也就是说已经有K-1个数字比堆顶大了，因此该堆顶最大也只可能是第K大了，更何况后面的数字还没比较）<ul><li>如果比较的值比堆顶小，说明这个值连第K大的资格都没有，直接丢弃，看下一个</li><li>如果比较的值比堆顶大，说明这个值有资格竞争第K大，相反的原堆顶的值这下只可能争取第K+1大了，他已经没有价值留在堆里，我们将其丢弃。之后将新到的值放进最小堆里，丢进去的时候，该堆会动态更新，此时会选举出新的所谓的第K大的值。</li></ul></li></ul></li></ol><p>我们可以看出通过方法二和方法三可以优化462题，更快速找到中位数</p><h1 id="2448-使数组相等的最小开销"><a href="#2448-使数组相等的最小开销" class="headerlink" title="2448. 使数组相等的最小开销"></a>2448. 使数组相等的最小开销</h1><p>这道题是今天要讲的重中之重。这道题是周赛的第三道困难题，前面两道题花了我太多时间，导致我这道题都没开始思考，然后切了个聊天看到我朋友说的思路，我直接写出来了，好家伙这下也不能是我想出来的。</p><h2 id="题目内容-2"><a href="#题目内容-2" class="headerlink" title="题目内容"></a>题目内容</h2><p>给你两个下标从 0 开始的数组 nums 和 cost ，分别包含 n 个 正 整数。</p><p>你可以执行下面操作 任意 次：</p><p>将 nums 中 任意 元素增加或者减小 1 。<br>对第 i 个元素执行一次操作的开销是 cost[i] 。</p><p>请你返回使 nums 中所有元素 相等 的 最少 总开销。</p><p> <strong>示例1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>], cost = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">14</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：我们可以执行以下操作使所有元素变为 <span class="number">2</span> ：</span><br><span class="line">- 增加第 <span class="number">0</span> 个元素 <span class="number">1</span> 次，开销为 <span class="number">2</span> 。</span><br><span class="line">- 减小第 <span class="number">1</span> 个元素 <span class="number">1</span> 次，开销为 <span class="number">3</span> 。</span><br><span class="line">- 减小第 <span class="number">2</span> 个元素 <span class="number">3</span> 次，开销为 <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">总开销为 <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">8</span> 。</span><br><span class="line">这是最小开销。</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], cost = [4,2,8,1,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组中所有元素已经全部相等，不需要执行额外的操作。</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>这道题和<a href="https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/">462. 最小操作次数使数组元素相等 II </a>的区别无非在于多了一个cost数组维护，很多人可能就想不出来，没做过462题的可能一脸懵。做过462题的人可能有点思路，但可能多过纠结于怎么使用cost数组。稍微转换一次思路，<code>cost[i]</code>可以看成是<code>nums[i]</code>的出现次数，可以说很多同学可能就豁然开朗了，题目瞬间降维维462题了，上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">allCost</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="comment">// 定义一个list把nums和对应的cost绑定在一起，同时记下cost的和。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i],cost[i]&#125;);</span><br><span class="line">            allCost+=cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据nums的大小对list进行排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//取cost和的中间值</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">midcost</span> <span class="operator">=</span> allCost/<span class="number">2</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">collectCost</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//函数的目的是为了获得达到中间cost值的i，即“加权中位数”的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            collectCost += list.get(i)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (collectCost&gt;=midcost) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再遍历一遍，将所有值与加权中位数求差并加权计算，得到结果。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> Long.valueOf(Math.abs(nums[i]-list.get(mid)[<span class="number">0</span>]));</span><br><span class="line">            ans+=temp*cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>增加了一个<code>allCost</code>还有<code>midcost</code>，当我们计算到积累的cost  <code>collectCost</code>  大于<code>midcost</code>时，得到<code>nums</code>里的数字，总损耗便出来了</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 中位数 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.23 剑指 Offer II 001. 整数除法</title>
      <link href="/2022/10/23/leetcode/jianzhi2-1/"/>
      <url>/2022/10/23/leetcode/jianzhi2-1/</url>
      
        <content type="html"><![CDATA[<p>这一节笔记主要记录一下位运算怎么在简单的运算能起到提到效率，第一次接触这个概念的时候，还是在一道快速乘的题，要求不使用乘除实现乘法，其实大家都能想到用加法然后for循环也能达到乘法的结果，但是这样的复杂度会达到O（n）级别，但如果能转换为二进制，同时引入位运算，效率将会极大提高，这里先引入快速乘的模板好做讲解。</p><h1 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ksc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处等价于（b%2==1）</span></span><br><span class="line">            <span class="keyword">if</span> ((b&amp;<span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res+=a;</span><br><span class="line">            &#125;</span><br><span class="line">            a+=a;</span><br><span class="line">            <span class="comment">// 此处等同于b/2</span></span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一次看代码我是十分懵逼的，但实际上从二进制角度又十分好理解，举个例子a&#x3D;5，b&#x3D;49，代码的逻辑如下</p><ol><li>将数字b转换为二进制，b&#x3D;110001</li><li>看二进制数字的末位是1还是0，代码中<code>(b&amp;1) != 0</code>就是为此做判断<ul><li>是1的情况：说明之后二进制在右移时会把1抛弃掉，同时也代表着该数除以2的余数为奇数，这个时候我们要把多出来的数特别的加回去，也就是<code>res+=a</code></li><li>是0的情况：不做处理</li></ul></li><li><strong>这一步和第四步没有先后顺序，可以颠倒</strong>，因为要将b右移了，此时a的大小要翻一倍，即  <code>a+=a</code></li><li>b右移，直至b为0，重复2到4步。</li></ol><p>仅仅这么描述挺生涩的，这里用另一个角度助于理解，就是从一开始for循环一个b，也就是（a+a+a+…+a)加b次，按前面的例子就是a加49次。改变为二进制就变成了（a×32）+（a×16）+ （a×1），是不是就明白了，实际上就是将49&#x3D;32+16+1，也就是二进制数字上（110001）的三个1代表的二进制转为十进制大小32、16、1，因此第三步a大小翻倍以及第二步只看1就可以理解了。</p><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>首先上个原题，这道题实际上用的方法和上面没区别。只不过我们在做题目的时候，往往要考虑的还有符号以及范围。</p><p>在幂函数里面如果指数&lt;0的时候，我们要将指数转换为正数，转换方法为<br>$$<br>a^b &#x3D;  ({1 \over a} ) ^ {-b}<br>$$<br><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n) - 力扣（LeetCode）</a></p><p>上题为快速幂的题，同样我们先上题解，再使其与上面快速乘的题解作对比</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            n=-n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 区别1</span></span><br><span class="line">                res*=x;</span><br><span class="line">            &#125;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//区别2</span></span><br><span class="line">            x*=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码与快速乘的代码相比，除去考虑符号的代码块，只有两个区别，两个区别其实就是把**+<strong>改为了</strong>×**，如果说多个数字相加就是乘法，理所当然的多个乘法就是幂运算了</p><h1 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h1><p>在介绍完前面的快速乘快速幂，我们开始讲这一道题——整数除法，乘法用加法代替，那么理所当然除法就要用减法代替，但是这道题还得考虑范围问题，就显得比较麻烦。先放题解。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 32 位最大值：2^31 - 1 = 2147483647</span></span><br><span class="line">        <span class="comment">// 32 位最小值：-2^31 = -2147483648</span></span><br><span class="line">        <span class="comment">// -2147483648 / (-1) = 2147483648 &gt; 2147483647 越界了</span></span><br><span class="line">        <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> (a &gt; <span class="number">0</span>)^(b &gt; <span class="number">0</span>) ? -<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 首先，右移的话，再怎么着也不会越界</span></span><br><span class="line">            <span class="comment">// 其次，无符号右移的目的是：将 -2147483648 看成 2147483648</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意，这里不能是 (a &gt;&gt;&gt; i) &gt;= b 而应该是 (a &gt;&gt;&gt; i) - b &gt;= 0</span></span><br><span class="line">            <span class="comment">// 这个也是为了避免 b = -2147483648，如果 b = -2147483648</span></span><br><span class="line">            <span class="comment">// 那么 (a &gt;&gt;&gt; i) &gt;= b 永远为 true，但是 (a &gt;&gt;&gt; i) - b &gt;= 0 为 false</span></span><br><span class="line">            <span class="keyword">if</span> ((a&gt;&gt;&gt;i)-b&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                a-=(b&lt;&lt;i);</span><br><span class="line">                <span class="comment">//res一旦超出范围直接returrnInteger.MIN_VALUE</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE - (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                res+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span>?res:-res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题用一种比较巧妙的方式，使得空间和时间复杂度都是常量级别，注释来自<a href="https://leetcode.cn/problems/xoh6Oh/solution/jian-dan-yi-dong-javac-pythonjs-zheng-sh-e8r6/">简单易懂Java&#x2F;C++ &#x2F;Python&#x2F;js&#x2F;go - 整数除法(剑指) - 整数除法 - 力扣（LeetCode）</a>，感谢大佬的题解。前面几行很好理解，主要就是对符号进行判断，for里面使用的思路与快速乘快速减无异，与快速乘从小加到大相反，快速减是从大减到小。一般在范围内，便做一次减法运算，更新res值。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.9 剑指59题——从单调栈的思维下手</title>
      <link href="/2022/10/09/leetcode/jianzhi59/"/>
      <url>/2022/10/09/leetcode/jianzhi59/</url>
      
        <content type="html"><![CDATA[<p>​发现最近做题常做常新，果然还是得靠积累，以前每天做题都感觉每天都是新的知识点，完全不知道这知识点怎么用。但是做多了发现有好多种解法有既视感，感觉有了整理解法的资本，上次整理了位运算相关的知识，这里整理一下单调栈的知识，顺便审视一下自己做题的一个错误解法。</p><h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定一个数组 <em>nums</em> 和滑动窗口的大小 <em>k</em>，请找出所有滑动窗口里的最大值。</p><p><strong>输入</strong>：nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</p><p><strong>输出</strong>：[3,3,5,5,6,7] </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">-------------------------     -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h1 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h1><h2 id="最大堆vs单调栈"><a href="#最大堆vs单调栈" class="headerlink" title="最大堆vs单调栈"></a>最大堆vs单调栈</h2><p>这题一出来，我第一个思路就是使用优先队列（最大堆），毕竟用现成的对象和封装好的方法，可以实现维护一个长度为k的堆，滑动窗口每新增一个便丢进堆里排序，左侧移出窗口可以使用remove(Object o)直接删除堆里要素，但很明显这是一个超时的做法，下面附上解题代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxqueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            maxqueue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k-<span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == k-<span class="number">1</span>) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = maxqueue.peek();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxqueue.remove(nums[i-k]);</span><br><span class="line">            maxqueue.offer(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = maxqueue.peek();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​我们知道最大堆实际上就是完全二叉树维护的，无论是查找还是新增都需要一定的时间和空间复杂度，而且k个元素是一直需要维护的，k越大空间复杂度高时间复杂度自然也高。因此需要寻找其他解法，这个时候就要提一下单调栈的概念了，也就是本题的一个优解。单调栈只需要比较栈顶就可以实现获得最小值的效果，这比最大堆好太多。</p><p>​引入单调栈这个概念，先介绍一道使用了单调栈解法的题，也就是最经典的题目<a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水 - 力扣（LeetCode）</a>接雨水题，这道题我其实很喜欢空间换时间的解法，也就是维护两个数组的解法并且优化为双指针解法，这里不做赘述，仅提示该题并不只有一种解法。</p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>何为单调栈？概念其实很简单，单调栈就是单调递增、单调递减的栈。</p><p><strong>单调栈的作用：</strong>把序列中每个元素放到单调栈中进行维护就可以在 <em>O</em>(<em>n</em>) 的时间复杂度内求出区间每个元素为最大值&#x2F;最小值时。</p><p>单调栈插入模板（以单调递减栈为例）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// insert element x in mono_stack</span><br><span class="line">void insert(stack&lt;int&gt;&amp; mono_stack, int x) &#123;</span><br><span class="line">// operations #1</span><br><span class="line">    // 当栈非空且栈顶元素小于等于当前元素时，出栈,这是因为只保存递减部分，递增不保留。</span><br><span class="line">while (!mono_stack.empty() &amp;&amp; mono_stack() &lt; x) &#123;</span><br><span class="line">  mono_stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">// operations #2</span><br><span class="line">mono_stack.push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​他的实现可以说是十分简单，但停留于此是不够的，我们应该学会这个方法什么时候能使用，要怎么改用使其符合我们的题意。</p><p>​首先我们把代码分成两个部分，操作1（operation1）还有操作2（operation2），操作2为入栈操作，操作1为出栈操作。其中操作2是必定执行的，也就是每次都会把值放进栈里面，而操作1是可选操作的，这也保证了不会出现<strong>空指针异常</strong>。大部分的修改模板操作都在操作1这个while里面，我愿称操作1为代码的核心代码。操作1的意思便是当栈非空，且我们遇到比栈顶大的值x，便把栈顶抛掉，继续判断下一个栈顶是不是比x小，我们不断抛弃比x小的值，最后放进x作为新的栈顶。从这个现象我总结了两条单调递减栈的现象或者说规律，可以用做做题的思路。单调递增同理可推，故不做累述。</p><ol><li><p><strong>栈顶是这个栈的最小元素。</strong>那是因为我们在操作1每次都会抛弃掉比新来的值小的值，这样就保证了栈中的所有值只可能比栈顶大，不可能比栈顶小。</p></li><li><p><strong>单调递减栈本质上是极大值与极大值的比较</strong>。该情况出现在有多个极大值的情况，我说的这个现象确实是很少人会去观察的点，故先做这个归纳。什么叫做极大值与极大值比较呢。首先我们要明白极大值，也就是左侧递增，右侧递减，该处导数为0的一个函数值（数学概念已经基本忘光可能不严谨，请结合自己的数学知识理解即可）。首先根据单调递减栈的特性，第一个保留在栈底比较久的值我们完全可以判断为第一个极大值，因为第一个极大值前的值基本不会得到保留，只会被不断的抛出更新。接着我们根据两个极大值一般分成两种情况</p><ul><li><strong>第一个极大值小于第二个极大值</strong>：在这种情况下为了保证单调递减栈的特性，第二个极大值前面所有的值都会被抛出，第二个极大值将会取代上一个极大值的位置。我愿称之为极值更新。</li><li><strong>第一个极大值大于或者等于第二个极大值</strong>：在这种情况下，两个极值之间形成的凹处的值都会被抛弃（递减部分不会被抛出），但第一个极大值不会被抛出，它仍然会保存在栈里，此时将新的极大值加入。</li><li><strong>只有递减部分得到保留入栈，这也是单调递减栈中“递减“两个字的真正含义</strong></li></ul><p>当然上面的情况仅存在于while条件为模板的情况下，所以修改while条件判断就不一定是单调递减栈了，故谨慎改用此处。</p></li></ol><p>​第一个规律可以说基本上没什么用，这是简单的不能再简单的规律，但是至少要学会根据第一个规律，实现单调栈代码。比较重要的还得是第二个规律。既然极大值都提到了，那么凹函数什么的想必也能想象得到，没错接雨水这道题用的正是第二个规律。我们本身就是求凹处的值，那么需要比较的就是两个极大值，该题的变种在于我们往栈保存的是数组的标签，计算宽度和高度求面积，思路懂了，这道题几乎迎刃而解，放个接雨水题解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="type">int</span> <span class="variable">currWidth</span> <span class="operator">=</span> i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currHeight</span> <span class="operator">=</span> Math.min(height[left], height[i]) - height[top];</span><br><span class="line">                ans += currWidth * currHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>​终于我们可以回归到本文的题目，我们在接雨水这道题需要知道两个极值，需要知道抛出的值，因此使用单调栈十分完美。而在滑动窗口这道题，我们加入了一个新的机制，取出值，在单调栈中我们只需要不断的入栈，然后将不符合操作1while条件的值抛出去，概括一下，这里有一个点，栈的规律先到的值永远只会在栈底，后到的值只可能把他抛出或者堆在栈底的上面。但是移动窗口这道题，随着窗口的移动，我们要<strong>把先到的极大值丢掉</strong>，很明显栈这个结构是实现不了。</p><p>​聪明的人肯定想到了，栈不行那我可以用队列啊，没错单调队列便是这么个效果。因此我们可以使用单调队列来维护窗口的最大值，将“过气”（不在窗口）的极大值抛出去。其实也就把栈的另一个口打开，因为两个口都能抛出值，因此我们使用双向队列（Deque）来实现单调队列。此时，栈顶成了队头，栈尾成了队尾。这个解法很明显相对最大堆，我们可以抛弃超级多凹处的值，并且还只需要和队尾比较即可，空间和时间复杂度都极大降低。</p><p>​题目已经显而易见，我们只要每次都弹出极大值即可。最后放出该题题解</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 双向队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 形成窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 当数组递增，很明显靠前的最小值都会被淘汰，并且不值得保存，我们只取极大值放进队列。</span></span><br><span class="line">            <span class="comment">// 数组的递增可以扩展到两个峰值的递增，我们只保留右侧较大峰</span></span><br><span class="line">            <span class="comment">// 具体操作为删除上一个最小值</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放进第一个值</span></span><br><span class="line">        res[<span class="number">0</span>] = deque.peekFirst();</span><br><span class="line">        <span class="comment">// 移动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 最大值要出栈</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i-k] == deque.peekFirst()) &#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(nums[i]);</span><br><span class="line">            res[i-k+<span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.10.2 剑指56题</title>
      <link href="/2022/10/02/leetcode/jianzhi56/"/>
      <url>/2022/10/02/leetcode/jianzhi56/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例1</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><h2 id="解法讲解及心得"><a href="#解法讲解及心得" class="headerlink" title="解法讲解及心得"></a>解法讲解及心得</h2><p>这题可以说是leetcode136题的进阶版<a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p>同时也不得不让人感慨位运算的神奇，位运算可以用来做快速幂计算，同时还可以用在树状数组还有本题的查找不同的题目中。</p><p>在讲这道题之前想先记下有意思的几种位运算的方法</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或 ^"></a>异或 ^</h3><p>异或运算有以下三个性质。</p><ol><li>任何数和 00 做异或运算，结果仍然是原来的数，即a⊕0&#x3D;a</li><li>任何数和其自身做异或运算，结果是 0，即 a⊕a&#x3D;0</li><li>异或运算满足交换律和结合律，即 a⊕b⊕a&#x3D;b⊕a⊕a&#x3D;b⊕(a⊕a)&#x3D;b⊕0&#x3D;b</li></ol><p>可以看到这个异或运算在寻找只出现一次的数字，能起到关键作用，我们只需要将数组从头异或到最后，便可以得到我们的答案。</p><h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>lowbit这个概念我是从树状数组知道的，树状数组是一个求前缀和和单点更新的数组，查找和更新的概率都是O（logn），但这类数组实际上除了特定题，我觉得一般很少看到，暂时做了解即可，它出现在<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/?favorite=xb9nqhhg">剑指 Offer 51. 数组中的逆序对 - 力扣（LeetCode）</a>可以从这道题了解树状数组的用法。</p><p>言归正传，我们假设一个数字x，lowbit运算为x&amp;（-x）这个运算可以得到x二进制表示中最后的“1”，这确实十分神奇，为什么不需要知道，知道他能实现这个效果就行，比如010100经过lowbit运输为000100；</p><p>在了解完这两个解题技巧之后，我们开始正式讲这道题的解法：</p><ol><li><strong>我们首先对整个数组进行异或运算，如下公式：</strong></li></ol><p><em>a</em>⊕<em>a</em>⊕<em>b</em>⊕<em>b</em>⊕…⊕<em>x</em>⊕<em>y</em></p><p>&#x3D;0⊕0⊕…⊕<em>x</em>⊕<em>y</em></p><p>&#x3D;<em>x</em>⊕<em>y</em></p><p>&#x3D;ret</p><p>很明显我们会发现这样没办法得到两个数字，而是得到他们的异或。但是巧妙的地方就在于我们知道x和y是必不相等的，所以他们两的异或得到的二进制的值必然不为0，于是有了下面的步骤</p><ol start="2"><li><strong>对ret进行lowbit运算</strong></li></ol><p>我们已经知道了ret不为0，然后我们使用lowbit能得到ret最靠后的“1”，那么这代表什么呢？</p><p>这代表x和y的二进制表达在这一位上他们是不一样的，要么x在这一位上为0，y为1；要么相反x在这一位上是1，y为0。</p><p>div&#x3D;ret&amp;（-ret）</p><p>有了这样的运算之后，我们看第三个步骤</p><ol start="3"><li><strong>对原数组进行分组计算</strong></li></ol><p>这一步简直是神来之笔，只能说没做过这类型的题简直不可能想出这个方法，有天赋的人除外了。</p><p>我们这一步要做到两个效果</p><ul><li>相同的数字必定在一组</li><li>返回的两个不同数字必定在不同的组</li></ul><p>我们通过lowbit运算之后得到的div，也就是最靠后的“1”的数字，用来和数组中的所有数进行与（&amp;）运算，将这一位上与div相同的分到一组，不相同的分到另一组。很明显，我们已经巧妙的将两个不同数字分开的同时，将相同的数字放到了一组。最后我们能得到两个数字，这便是题目要的答案</p><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 我们首先对整个数组进行异或运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            ret ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对ret进行lowbit运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> ret &amp; (-ret);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对原数组进行分组计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((div&amp;num)==<span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.9.16 剑指43题</title>
      <link href="/2022/09/16/leetcode/jianzhi43/"/>
      <url>/2022/09/16/leetcode/jianzhi43/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5</p><p><strong>示例1：</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt; 2^31</code></li></ul><h2 id="解法讲解："><a href="#解法讲解：" class="headerlink" title="解法讲解："></a>解法讲解：</h2><p>该题十分独特所以放上来记录一下</p><p>如果玩过行李箱那个密码锁能很好理解，没玩过也无所谓。</p><p>我们常见的最暴力的解法就是从1遍历到n，这是效率十分低下的解法。</p><p>但如果仔细观察规律，通过计算每一个位置在1~n里面出现1的次数，最后再将所有位置数到1的数量追加起来就可以得到最终结果</p><p>举个例子讲解一下：</p><p>拿24x5做例子</p><p>其中x为我们锁定的位置<strong>cur</strong></p><p>24为高位<strong>high</strong></p><p>5为低位<strong>low</strong></p><p>我们可以用digit表示我们目前锁定的位置<strong>digit</strong>（当前digit&#x3D;10）</p><p>我们开始计算十位的数量</p><ol><li>当十位为0时，那么也就是说1不可能出现在2410之后，所以实际上只有<strong>0010~2319</strong>这段数字区间十位会出现1，我们暂时把十位遮掉，可以发现变成了计算<strong>000~239</strong>的总数量，也就是240；（归纳：当锁定位置为0时，只看高位数量）</li><li>当十位为1，那么出现1的次数很明显会比第一个情况有所增加，这个时候<strong>0010~2415</strong>这段区间十位会出现1，同样遮掉十位数，这下变成了<strong>000~245</strong>的总数量，总共为246；（归纳：当锁定位置为1时，要同时看高低位数量）</li><li>当十位&gt;1时，和上面一样的推理，这个时候区间就会变成<strong>0010~2419</strong>这个区间，这是因为当十位数大于1时，假设为2，小于2420这个数字且十位数为1的最大数字为2419，遮掉十位数，求<strong>000~249</strong>，总共为250；（归纳：当锁定位置大于1时，只看高位数量，（高位+1）*10）</li></ol><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (high!=<span class="number">0</span>||cur!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur==<span class="number">0</span>) &#123;</span><br><span class="line">                res += high*digit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur==<span class="number">1</span>) &#123;</span><br><span class="line">                res += high*digit+low+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (high+<span class="number">1</span>)*digit;</span><br><span class="line">            &#125;</span><br><span class="line">            digit*=<span class="number">10</span>;</span><br><span class="line">            low = cur*digit+low;</span><br><span class="line">            cur = high%<span class="number">10</span>;</span><br><span class="line">            high = high/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud中nacos config的一些坑</title>
      <link href="/2022/06/29/spring/nacosconfig/"/>
      <url>/2022/06/29/spring/nacosconfig/</url>
      
        <content type="html"><![CDATA[<p>我在弄nacos config按照网上的流程打了一遍，发现并没有在日志弹出配置文件的名字，可能是版本的问题<br>解决方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后便能在控制台的日志看到<br><img src="https://s3.bmp.ovh/imgs/2022/06/29/c0f28361f6dbe63e.png" alt="img"><br>无视第三行，直接看第二行nacos相关的，复制gulimall-coupon.properties即可</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.15 77题</title>
      <link href="/2022/05/15/leetcode/77/"/>
      <url>/2022/05/15/leetcode/77/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfsa(res,list,n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsa</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list,<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> begin)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size()==k) &#123;</span><br><span class="line">            List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">            res.add(list1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            dfsa(res,list,n,k,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感谢"><a href="#做题感谢" class="headerlink" title="做题感谢"></a>做题感谢</h1><p>回溯法这类题做多了十分简单</p><p>在for那里，设置begin有点学问，可以多试试</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.13 108题</title>
      <link href="/2022/05/13/leetcode/108/"/>
      <url>/2022/05/13/leetcode/108/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="img"></p><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> travel(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">travel</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = travel(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = travel(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><p>首先是递归函数的参数，因为我们需要用到多的参数，所以我们要重新定义一个递归函数出来。</p><p>其他的与普通递归函数无异。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.9 669题</title>
      <link href="/2022/05/09/leetcode/669/"/>
      <url>/2022/05/09/leetcode/669/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例1</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><p>树中节点数在范围 [1, 104] 内</p></li><li><p>0 &lt;&#x3D; Node.val &lt;&#x3D; 104</p></li><li><p>树中每个节点的值都是 唯一 的</p></li><li><p>题目数据保证输入是一棵有效的二叉搜索树</p></li><li><p>0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 104</p></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val&lt;low) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val&gt;high) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><p>这可能是我最近做的最糟糕的一题，其实本题并不难，看了解法逻辑十分清晰。</p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/image-20220509105537316.png" alt="imgae12"></p><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><pre><code>    TreeNode</code></pre><p><strong>（2）确定终止条件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>（3）确定单层递归的逻辑</strong></p><p>ps：<strong>注意这里我本来以为和450题一样，修剪就行，但实际上修剪一次和修剪多次是不一样了，所以解法大不相同。</strong></p><p>​如果root（当前节点）的元素小于左边界low的数值，那么应该递归右子树，并返回右子树符合条件的头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val&lt;low) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​如果root（当前节点）的元素大于左边界high的数值，那么应该递归左子树，并返回左子树符合条件的头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val&gt;high) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​接下来将下一层递归处理左子树的结果赋值给root.left、处理右子树的结果赋值给root.right，最后返回root节点，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root.left = trimBST(root.left,low,high);</span><br><span class="line">root.right = trimBST(root.right,low,high);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.7 450题</title>
      <link href="/2022/05/07/leetcode/450/"/>
      <url>/2022/05/07/leetcode/450/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt="img"></p><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 [0, 104].</li><li>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</li><li>节点值唯一</li><li>root 是合法的二叉搜索树</li><li>-105 &lt;&#x3D; key &lt;&#x3D; 105</li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">         <span class="comment">//情况一找不到该节点，返回root</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">//情况二，该节点左右孩子均为空，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//情况三，左孩子为空，右孩子不为空</span></span><br><span class="line">            <span class="keyword">if</span> (root.left==<span class="literal">null</span> )</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="comment">//情况四，右孩子为空，左孩子不为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right==<span class="literal">null</span> )</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">//情况五，左右孩子都不为空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right; <span class="comment">// 首先找到删除节点的右子树</span></span><br><span class="line">                <span class="comment">//找到右子树中最小的数字</span></span><br><span class="line">               <span class="keyword">while</span> (cur.left!=<span class="literal">null</span>) &#123; </span><br><span class="line">                   cur =cur.left;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//将原本的左子树拼接上去</span></span><br><span class="line">                cur.left=root.left;</span><br><span class="line">               <span class="comment">// 取代root</span></span><br><span class="line">                root = root.right;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right,key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感想"><a href="#做题感想" class="headerlink" title="做题感想"></a>做题感想</h1><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><pre><code>    TreeNode</code></pre><p><strong>（2）确定终止条件</strong></p><pre><code>    即遍历到null的时候</code></pre><p><strong>（3）确定单层递归的逻辑</strong></p><p>主要分析五种情况</p><ul><li>第一种情况：没有找到删除的节点</li><li>找到了删除的节点<ul><li>第二种情况：该节点左右孩子都为空。</li><li>第三种情况：被删除的节点左孩子为空，右孩子不为空。</li><li>第四种情况：被删除的节点右孩子为空，左孩子不为空。</li><li>第五种情况：被删除的节点左右孩子都不为空。</li></ul></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//情况一找不到该节点，返回root</span><br><span class="line">      if (root == null) return root;</span><br><span class="line">      if (root.val == key) &#123;</span><br><span class="line">          //情况二，该节点左右孩子均为空，返回null</span><br><span class="line">          if (root.left==null &amp;&amp; root.right==null)return null;</span><br><span class="line">          //情况三，左孩子为空，右孩子不为空</span><br><span class="line">          if (root.left==null )</span><br><span class="line">              return root.right;</span><br><span class="line">          //情况四，右孩子为空，左孩子不为空</span><br><span class="line">          else if (root.right==null )</span><br><span class="line">              return root.left;</span><br><span class="line">          //情况五，左右孩子都不为空</span><br><span class="line">          else &#123;</span><br><span class="line">             TreeNode cur = root.right; // 首先找到删除节点的右子树</span><br><span class="line">              //找到右子树中最小的数字</span><br><span class="line">             while (cur.left!=null) &#123; </span><br><span class="line">                 cur =cur.left;</span><br><span class="line">             &#125;</span><br><span class="line">             //将原本的左子树拼接上去</span><br><span class="line">              cur.left=root.left;</span><br><span class="line">             // 取代root</span><br><span class="line">              root = root.right;</span><br><span class="line">              return root;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022.5.6 701题</title>
      <link href="/2022/05/06/leetcode/701/"/>
      <url>/2022/05/06/leetcode/701/</url>
      
        <content type="html"><![CDATA[<h1 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h1><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果。</p><p><strong>示例1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt="img"></p><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>树中的节点数将在 [0, 104]的范围内。</p></li><li><p>-108 &lt;&#x3D; Node.val &lt;&#x3D; 108</p></li><li><p>所有值 Node.val 是 独一无二 的。</p></li><li><p>-108 &lt;&#x3D; val &lt;&#x3D; 108</p></li><li><p>保证 val 在原始BST中不存在。</p></li></ul><h1 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做题感谢"><a href="#做题感谢" class="headerlink" title="做题感谢"></a>做题感谢</h1><ol><li><p>首先先写上return root；无论做何种算法题，先把结果return，亦可return null，之后再改即可</p></li><li><p>之后使用递归三部曲：</p><p><strong>（1）确定递归函数的参数和返回值</strong></p><p>​TreeNode</p><p><strong>（2）确定终止条件</strong></p><p>​即遍历到null的时候</p><p><strong>（3）确定单层递归的逻辑</strong></p></li></ol><p></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">&#125;</span><br><span class="line">if (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置说明</title>
      <link href="/2022/05/05/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/05/05/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、每次修改config.yml文件之后要先使用hexo server修改配置并查看预览。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>2、预览无问题之后，上传到github</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;作出的修改&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>3、同步到github托管</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>4、当出现如下图的error时</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">fatal: <span class="title">unable</span> <span class="title">to</span> <span class="title">access</span> &#x27;<span class="title">https</span>://<span class="title">github.com</span>/<span class="title">yu1147</span>/<span class="title">blog.git</span>/&#x27;: <span class="title">OpenSSL</span> <span class="title">SSL_read</span>: <span class="title">Connection</span> <span class="title">was</span> <span class="title">reset</span>, <span class="title">errno</span> 10054</span></span><br></pre></td></tr></table></figure><p>输入下面指令即可</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/05/05/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/05/05/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shu.pension.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About me</title>
      <link href="/2022/05/05/%E7%BD%AE%E9%A1%B6%E9%A1%B5/aboutme/"/>
      <url>/2022/05/05/%E7%BD%AE%E9%A1%B6%E9%A1%B5/aboutme/</url>
      
        <content type="html"><![CDATA[<p>cover: <a href="https://s3.bmp.ovh/imgs/2022/05/14/5af5ca311486c8e8.jpg">https://s3.bmp.ovh/imgs/2022/05/14/5af5ca311486c8e8.jpg</a></p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>我是陈诗杰。目前上海大学就读研究生在读。主要钻研后端开发、神经网络架构搜索。</p><h1 id="技术方向"><a href="#技术方向" class="headerlink" title="技术方向"></a>技术方向</h1><div align=left><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/java.png" alt="java" style="zoom: 15%;float:left" /></div><div align=left><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/python.png" alt="python" style="zoom:15%;float:left" /></div><div align=left><img src="https://cdn.jsdelivr.net/gh/yu1147/cloudimg/img/linux.png" alt="linux" style="zoom:15%;float:left" /></div><p> &nbsp</p><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>qq：1147669839</p><p>微博：@学徒型谕桑</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=595608323&bvid=BV1yB4y1m7PP&cid=573439540&page=1&as_wide=1&high_quality=1&danmaku=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0; " sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/04/hello-world/"/>
      <url>/2022/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
